<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="fun.timu.oj.judge.mapper.ProblemMapper">

    <resultMap id="BaseResultMap" type="fun.timu.oj.judge.model.DO.ProblemDO">
        <id property="id" column="id"/>
        <result property="title" column="title"/>
        <result property="titleEn" column="title_en"/>
        <result property="description" column="description"/>
        <result property="descriptionEn" column="description_en"/>
        <result property="problemType" column="problem_type"/>
        <result property="difficulty" column="difficulty"/>
        <result property="timeLimit" column="time_limit"/>
        <result property="memoryLimit" column="memory_limit"/>
        <result property="supportedLanguages" column="supported_languages"/>
        <result property="solutionTemplates" column="solution_templates"/>
        <result property="inputDescription" column="input_description"/>
        <result property="outputDescription" column="output_description"/>
        <result property="hasInput" column="has_input"/>
        <result property="inputFormat" column="input_format"/>
        <result property="examples" column="examples"/>
        <result property="status" column="status"/>
        <result property="visibility" column="visibility"/>
        <result property="submissionCount" column="submission_count"/>
        <result property="acceptedCount" column="accepted_count"/>
        <result property="creatorId" column="creator_id"/>
        <result property="hints" column="hints"/>
        <result property="constraints" column="constraints"/>
        <result property="notes" column="notes"/>
        <result property="metadata" column="metadata"/>
        <result property="isDeleted" column="is_deleted"/>
        <result property="createdAt" column="created_at"/>
        <result property="updatedAt" column="updated_at"/>
    </resultMap>
    <sql id="Base_Column_List">
        id
        ,title,title_en,description,description_en,problem_type,
        difficulty,time_limit,memory_limit,supported_languages,solution_templates,
        input_description,output_description,has_input,input_format,examples,
        status,visibility,submission_count,accepted_count,creator_id,
        hints,constraints,notes,metadata,is_deleted,
        created_at,updated_at    </sql>

    <!-- 基础查询条件片段 -->
    <sql id="Base_Where_Clause">
        WHERE is_deleted = 0
    </sql>

    <!-- 统一的分布分析接口 -->
    <select id="getDistributionStatistics" resultType="java.util.HashMap">
        <choose>
            <!-- 按难度分布 -->
            <when test="criteria.dimension.name() == 'DIFFICULTY'">
                SELECT difficulty as dimension_value,
                difficulty as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                <if test="criteria.includeDetails">
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    ROUND(AVG(time_limit), 2) as avg_time_limit,
                    ROUND(AVG(memory_limit), 2) as avg_memory_limit,
                    COUNT(CASE WHEN submission_count = 0 THEN 1 END) as zero_submission_problems,
                    MIN(created_at) as earliest_problem_date,
                    MAX(created_at) as latest_problem_date,
                </if>
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                <if test="criteria.onlyNonEmpty">
                    AND difficulty IS NOT NULL
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY difficulty
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">
                        CASE difficulty
                        WHEN 'EASY' THEN 1
                        WHEN 'MEDIUM' THEN 2
                        WHEN 'HARD' THEN 3
                        ELSE 4
                        END ${criteria.orderDirection}
                    </when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按题目类型分布 -->
            <when test="criteria.dimension.name() == 'TYPE'">
                SELECT problem_type as dimension_value,
                problem_type as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                <if test="criteria.includeDetails">
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    COUNT(DISTINCT creator_id) as unique_creators,
                    ROUND(AVG(time_limit), 2) as avg_time_limit,
                    ROUND(AVG(memory_limit), 2) as avg_memory_limit,
                    COUNT(CASE WHEN submission_count = 0 THEN 1 END) as zero_submission_problems,
                    COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END) as easy_problems,
                    COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
                    COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END) as hard_problems,
                </if>
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                AND problem_type IS NOT NULL
                <if test="criteria.onlyNonEmpty">
                    AND problem_type != ''
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY problem_type
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">problem_type ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按语言支持分布 -->
            <when test="criteria.dimension.name() == 'LANGUAGE'">
                SELECT supported_languages as dimension_value,
                supported_languages as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                <if test="criteria.includeDetails">
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END) as easy_problems,
                    COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
                    COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END) as hard_problems,
                    COUNT(DISTINCT problem_type) as unique_types,
                    MIN(created_at) as earliest_problem_date,
                    MAX(created_at) as latest_problem_date,
                </if>
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                AND supported_languages IS NOT NULL
                <if test="criteria.onlyNonEmpty">
                    AND supported_languages != ''
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY supported_languages
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">supported_languages ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按状态分布 -->
            <when test="criteria.dimension.name() == 'STATUS'">
                SELECT status as dimension_value,
                CASE
                WHEN status = 0 THEN 'DISABLED'
                WHEN status = 1 THEN 'ACTIVE'
                WHEN status = 2 THEN 'DRAFT'
                ELSE 'UNKNOWN'
                END as dimension_name,
                COUNT(*) as total_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                <if test="criteria.includeDetails">
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    COUNT(DISTINCT creator_id) as unique_creators,
                    COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END) as easy_problems,
                    COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
                    COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END) as hard_problems,
                    MIN(created_at) as earliest_problem_date,
                    MAX(created_at) as latest_problem_date,
                    ROUND(AVG(DATEDIFF(CURRENT_DATE, created_at)), 2) as avg_age_days,
                </if>
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY status
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">status ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按创建者分布 -->
            <when test="criteria.dimension.name() == 'CREATOR'">
                SELECT creator_id as dimension_value,
                creator_id as dimension_name,
                COUNT(*) as total_problems,
                SUM(submission_count) as total_submissions_received,
                SUM(accepted_count) as total_accepted_received,
                ROUND(AVG(
                CASE
                WHEN submission_count > 0
                THEN (accepted_count * 100.0 / submission_count)
                ELSE 0
                END
                ), 2) as avg_acceptance_rate,
                <if test="criteria.includeDetails">
                    MIN(created_at) as first_problem_date,
                    MAX(created_at) as latest_problem_date,
                    DATEDIFF(MAX(created_at), MIN(created_at)) as creation_span_days,
                    COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                    COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 7 THEN 1 END) as recent_problems,
                    ROUND(COUNT(*) / GREATEST(DATEDIFF(CURRENT_DATE, MIN(created_at)), 1) * 365, 2) as
                    problems_per_year,
                </if>
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0 AND creator_id IS NOT
                NULL)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                AND creator_id IS NOT NULL
                <if test="criteria.timeRange != null">
                    AND created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY creator_id
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">creator_id ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">avg_acceptance_rate ${criteria.orderDirection}
                    </when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按时间限制分布 -->
            <when test="criteria.dimension.name() == 'TIME_LIMIT'">
                SELECT time_limit as dimension_value,
                CONCAT(time_limit, 'ms') as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                AND time_limit IS NOT NULL
                <if test="criteria.onlyNonEmpty">
                    AND time_limit > 0
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY time_limit
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">time_limit ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按内存限制分布 -->
            <when test="criteria.dimension.name() == 'MEMORY_LIMIT'">
                SELECT memory_limit as dimension_value,
                CONCAT(memory_limit, 'MB') as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                AND memory_limit IS NOT NULL
                <if test="criteria.onlyNonEmpty">
                    AND memory_limit > 0
                </if>
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY memory_limit
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">memory_limit ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>

            <!-- 按可见性分布 -->
            <when test="criteria.dimension.name() == 'VISIBILITY'">
                SELECT visibility as dimension_value,
                CASE
                WHEN visibility = 0 THEN 'PRIVATE'
                WHEN visibility = 1 THEN 'PUBLIC'
                ELSE 'UNKNOWN'
                END as dimension_name,
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(
                CASE
                WHEN SUM(submission_count) > 0
                THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0
                END, 2
                ) as acceptance_rate,
                ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0)), 2) as percentage
                FROM problem
                WHERE is_deleted = 0
                <if test="criteria.startTime != null">
                    AND created_at >= #{criteria.startTime}
                </if>
                <if test="criteria.endTime != null">
                    AND created_at &lt;= #{criteria.endTime}
                </if>
                GROUP BY visibility
                <if test="criteria.onlyNonEmpty">
                    HAVING COUNT(*) > 0
                </if>
                ORDER BY
                <choose>
                    <when test="criteria.orderBy == 'name'">visibility ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'percentage'">percentage ${criteria.orderDirection}</when>
                    <when test="criteria.orderBy == 'acceptance_rate'">acceptance_rate ${criteria.orderDirection}</when>
                    <otherwise>total_problems ${criteria.orderDirection}</otherwise>
                </choose>
            </when>
        </choose>

        <if test="criteria.limit != null">
            LIMIT #{criteria.limit}
        </if>
    </select>

    <!-- 统一推荐题目接口 -->
    <select id="getRecommendedProblems" resultMap="BaseResultMap">
        SELECT
        <include refid="Base_Column_List"/>
        FROM problem
        <include refid="Base_Where_Clause"/>
        AND status = 1
        <choose>
            <!-- 基于通过率的推荐 -->
            <when test="criteria.type.name() == 'ACCEPTANCE_RATE'">
                AND submission_count > 0
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
                <if test="criteria.minAcceptanceRate != null">
                    AND (accepted_count * 1.0 / submission_count) >= #{criteria.minAcceptanceRate}
                </if>
                <if test="criteria.maxAcceptanceRate != null">
                    AND (accepted_count * 1.0 / submission_count) &lt;= #{criteria.maxAcceptanceRate}
                </if>
                ORDER BY
                RAND() * (accepted_count / submission_count + 0.1) DESC,
                submission_count DESC
            </when>

            <!-- 基于相似性的推荐 -->
            <when test="criteria.type.name() == 'SIMILARITY'">
                <if test="criteria.baseProblemId != null">
                    AND id != #{criteria.baseProblemId}
                    AND (
                    problem_type = (SELECT problem_type FROM problem WHERE id = #{criteria.baseProblemId} AND
                    is_deleted = 0)
                    OR difficulty = (SELECT difficulty FROM problem WHERE id = #{criteria.baseProblemId} AND
                    is_deleted = 0)
                    )
                </if>
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
                ORDER BY submission_count DESC, accepted_count DESC
            </when>

            <!-- 基于热门度的推荐 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                <if test="criteria.timeRange != null">
                    AND created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
                ORDER BY
                submission_count * 0.7 + accepted_count * 0.3 +
                (CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 30 THEN 10 ELSE 0 END) DESC
            </when>

            <!-- 基于算法数据的推荐 -->
            <when test="criteria.type.name() == 'ALGORITHM_DATA'">
                AND submission_count > 0
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
                ORDER BY
                LEAST(submission_count / 50.0, 1) * 40 +
                (CASE
                WHEN submission_count = 0 THEN 0
                WHEN (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 70 THEN 30
                WHEN (accepted_count * 100.0 / submission_count) BETWEEN 10 AND 80 THEN 20
                ELSE 10
                END) +
                (CASE
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 30 THEN 20
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 90 THEN 15
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 180 THEN 10
                ELSE 5
                END) DESC
            </when>
        </choose>

        <if test="criteria.limit != null and criteria.limit > 0">
            LIMIT #{criteria.limit}
        </if>
    </select>

    <!-- 统一推荐题目接口（包含评分） -->
    <select id="getRecommendedProblemsWithScore" resultType="java.util.HashMap">
        SELECT
        id,
        title,
        title_en,
        difficulty,
        problem_type,
        submission_count,
        accepted_count,
        ROUND(
        CASE
        WHEN submission_count > 0
        THEN (accepted_count * 100.0 / submission_count)
        ELSE 0
        END, 2
        ) as acceptance_rate,
        time_limit,
        memory_limit,
        created_at,
        <choose>
            <!-- 基于通过率的推荐评分 -->
            <when test="criteria.type.name() == 'ACCEPTANCE_RATE'">
                ROUND(
                (accepted_count * 1.0 / GREATEST(submission_count, 1)) * 60 +
                LEAST(submission_count / 100.0, 1) * 40, 2
                ) as recommendation_score
            </when>

            <!-- 基于相似性的推荐评分 -->
            <when test="criteria.type.name() == 'SIMILARITY'">
                <if test="criteria.baseProblemId != null">
                    ROUND(
                    (CASE WHEN problem_type = (SELECT problem_type FROM problem WHERE id = #{criteria.baseProblemId}
                    AND is_deleted = 0) THEN 30 ELSE 10 END) +
                    (CASE WHEN difficulty = (SELECT difficulty FROM problem WHERE id = #{criteria.baseProblemId} AND
                    is_deleted = 0) THEN 25 ELSE 5 END) +
                    LEAST(submission_count / 100.0, 1) * 25 +
                    (CASE
                    WHEN submission_count > 0 AND (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 80 THEN 20
                    ELSE 10
                    END), 2
                    ) as recommendation_score
                </if>
                <if test="criteria.baseProblemId == null">
                    ROUND(submission_count * 0.6 + accepted_count * 0.4, 2) as recommendation_score
                </if>
            </when>

            <!-- 基于热门度的推荐评分 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                ROUND(
                submission_count * 0.7 +
                accepted_count * 0.3 +
                (CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 30 THEN 10 ELSE 0 END), 2
                ) as recommendation_score
            </when>

            <!-- 基于算法数据的推荐评分 -->
            <when test="criteria.type.name() == 'ALGORITHM_DATA'">
                ROUND(
                LEAST(submission_count / 50.0, 1) * 40 +
                (CASE
                WHEN submission_count = 0 THEN 0
                WHEN (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 70 THEN 30
                WHEN (accepted_count * 100.0 / submission_count) BETWEEN 10 AND 80 THEN 20
                ELSE 10
                END) +
                (CASE
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 30 THEN 20
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 90 THEN 15
                WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 180 THEN 10
                ELSE 5
                END) +
                (CASE WHEN status = 1 AND visibility = 1 THEN 10 ELSE 0 END), 2
                ) as recommendation_score
            </when>
        </choose>
        FROM problem
        <include refid="Base_Where_Clause"/>
        AND status = 1
        <choose>
            <!-- 基于通过率的推荐 -->
            <when test="criteria.type.name() == 'ACCEPTANCE_RATE'">
                AND submission_count > 0
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
                <if test="criteria.minAcceptanceRate != null">
                    AND (accepted_count * 1.0 / submission_count) >= #{criteria.minAcceptanceRate}
                </if>
                <if test="criteria.maxAcceptanceRate != null">
                    AND (accepted_count * 1.0 / submission_count) &lt;= #{criteria.maxAcceptanceRate}
                </if>
            </when>

            <!-- 基于相似性的推荐 -->
            <when test="criteria.type.name() == 'SIMILARITY'">
                <if test="criteria.baseProblemId != null">
                    AND id != #{criteria.baseProblemId}
                </if>
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
            </when>

            <!-- 基于热门度的推荐 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                <if test="criteria.timeRange != null">
                    AND created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
            </when>

            <!-- 基于算法数据的推荐 -->
            <when test="criteria.type.name() == 'ALGORITHM_DATA'">
                AND submission_count > 0
                <if test="criteria.difficulty != null">
                    AND difficulty = #{criteria.difficulty}
                </if>
                <if test="criteria.problemType != null and criteria.problemType != ''">
                    AND problem_type = #{criteria.problemType}
                </if>
            </when>
        </choose>

        ORDER BY recommendation_score DESC, submission_count DESC

        <if test="criteria.limit != null and criteria.limit > 0">
            LIMIT #{criteria.limit}
        </if>
    </select>


    <!-- 获取最受欢迎的题目类型和难度组合 -->
    <select id="getPopularProblemCategories" resultType="java.util.HashMap">
        SELECT
        problem_type,
        difficulty,
        COUNT(*) as total_count,
        SUM(submission_count) as total_submissions,
        SUM(accepted_count) as total_accepted,
        ROUND(SUM(accepted_count) / NULLIF(SUM(submission_count), 0), 4) as acceptance_rate
        FROM problem
        <include refid="Base_Where_Clause"/>
        AND status = 1
        AND submission_count > 0
        GROUP BY problem_type, difficulty
        ORDER BY total_submissions DESC, acceptance_rate DESC
        <if test="limit != null and limit > 0">
            LIMIT #{limit}
        </if>
    </select>


    <!-- 获取创建者活跃度分析 -->
    <select id="getCreatorActivityAnalysis" resultType="java.util.HashMap">
        SELECT creator_id,
               COUNT(*)                                                                          as total_problems,
               COUNT(CASE WHEN status = 1 THEN 1 END)                                            as active_problems,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= #{timeRange} THEN 1 END) as recent_problems,
               SUM(submission_count)                                                             as total_submissions_received,
               SUM(accepted_count)                                                               as total_accepted_received,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ), 2)                                                                       as avg_acceptance_rate,
               MIN(created_at)                                                                   as first_problem_date,
               MAX(created_at)                                                                   as latest_problem_date,
               DATEDIFF(MAX(created_at), MIN(created_at))                                        as activity_span_days,
               -- 活跃度等级
               CASE
                   WHEN COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= #{timeRange} THEN 1 END) &gt; 5
                       THEN 'VERY_ACTIVE'
                   WHEN COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= #{timeRange} THEN 1 END) &gt; 2
                       THEN 'ACTIVE'
                   WHEN COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= #{timeRange} THEN 1 END) &gt; 0
                       THEN 'MODERATE'
                   ELSE 'INACTIVE'
                   END                                                                           as activity_level,
               -- 专业度分析
               COUNT(DISTINCT difficulty)                                                        as difficulty_diversity,
               COUNT(DISTINCT problem_type)                                                      as type_diversity,
               COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                                   as hard_problems_count
        FROM problem
        WHERE is_deleted = 0
          AND creator_id IS NOT NULL
        GROUP BY creator_id
        HAVING COUNT(*) &gt; 0
        ORDER BY recent_problems DESC, total_problems DESC
    </select>

    <!-- 获取题目被访问热度分析 -->
    <select id="getProblemAccessHeatmap" resultType="java.util.HashMap">
        SELECT
        id,
        title,
        difficulty,
        problem_type,
        submission_count as access_count,
        accepted_count,
        ROUND(
        CASE
        WHEN submission_count &gt; 0
        THEN (accepted_count * 100.0 / submission_count)
        ELSE 0
        END, 2
        ) as acceptance_rate,
        created_at,
        DATEDIFF(CURRENT_DATE, created_at) as days_since_creation,
        -- 热度评分
        ROUND(
        submission_count * 0.6 +
        accepted_count * 0.3 +
        (CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 30 THEN 20 ELSE
        CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt; 90 THEN 10 ELSE 5 END END) * 0.1
        , 2) as heat_score,
        -- 热度等级
        CASE
        WHEN submission_count &gt; 100 THEN 'HOT'
        WHEN submission_count &gt; 50 THEN 'WARM'
        WHEN submission_count &gt; 10 THEN 'NORMAL'
        WHEN submission_count &gt; 0 THEN 'COOL'
        ELSE 'COLD'
        END as heat_level
        FROM problem
        WHERE is_deleted = 0 AND status = 1
        ORDER BY heat_score DESC
        <if test="limit != null">
            LIMIT #{limit}
        </if>
    </select>

    <!-- 获取题目解题模式分析 -->
    <select id="getProblemSolvingPatternAnalysis" resultType="java.util.HashMap">
        SELECT
        id,
        title,
        difficulty,
        problem_type,
        submission_count,
        accepted_count,
        ROUND(
        CASE
        WHEN submission_count &gt; 0
        THEN (accepted_count * 100.0 / submission_count)
        ELSE 0
        END, 2
        ) as acceptance_rate,
        -- 解题模式分析
        CASE
        WHEN submission_count = 0 THEN 'UNTOUCHED'
        WHEN submission_count &gt; 0 AND accepted_count = 0 THEN 'UNSOLVED'
        WHEN (accepted_count * 100.0 / submission_count) &gt;= 80 THEN 'EASY_SOLVE'
        WHEN (accepted_count * 100.0 / submission_count) &gt;= 50 THEN 'MODERATE_SOLVE'
        WHEN (accepted_count * 100.0 / submission_count) &gt;= 20 THEN 'HARD_SOLVE'
        ELSE 'VERY_HARD_SOLVE'
        END as solving_pattern,
        -- 尝试强度
        CASE
        WHEN submission_count = 0 THEN 'NO_ATTEMPT'
        WHEN submission_count &lt;= 5 THEN 'LOW_ATTEMPT'
        WHEN submission_count &lt;= 20 THEN 'MODERATE_ATTEMPT'
        WHEN submission_count &lt;= 50 THEN 'HIGH_ATTEMPT'
        ELSE 'VERY_HIGH_ATTEMPT'
        END as attempt_intensity,
        time_limit,
        memory_limit
        FROM problem
        WHERE is_deleted = 0 AND status = 1
        ORDER BY submission_count DESC
        <if test="limit != null">
            LIMIT #{limit}
        </if>
    </select>

    <!-- 获取题目难度偏好分析 -->
    <select id="getDifficultyPreferenceAnalysis" resultType="java.util.HashMap">
        SELECT difficulty,
               COUNT(*)                                             as total_problems,
               SUM(submission_count)                                as total_submissions,
               SUM(accepted_count)                                  as total_accepted,
               ROUND(AVG(submission_count), 2)                      as avg_submissions_per_problem,
               ROUND(
                       CASE
                           WHEN SUM(submission_count) &gt; 0
                               THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                           ELSE 0
                           END, 2
               )                                                    as overall_acceptance_rate,
               -- 受欢迎程度
               ROUND(SUM(submission_count) * 100.0 / (SELECT SUM(submission_count) FROM problem WHERE is_deleted = 0),
                     2)                                             as popularity_percentage,
               -- 题目质量指标
               COUNT(CASE WHEN submission_count &gt; 10 THEN 1 END) as quality_problems,
               COUNT(CASE WHEN submission_count = 0 THEN 1 END)     as untouched_problems
        FROM problem
        WHERE is_deleted = 0
        GROUP BY difficulty
        ORDER BY CASE difficulty
                     WHEN 'EASY' THEN 1
                     WHEN 'MEDIUM' THEN 2
                     WHEN 'HARD' THEN 3
                     ELSE 4
                     END
    </select>

    <!-- V2版本：性能分析聚合接口 -->

    <!-- 获取题目性能指标分析 -->
    <select id="getProblemPerformanceMetrics" resultType="java.util.HashMap">
        SELECT
        id,
        title,
        difficulty,
        problem_type,
        time_limit,
        memory_limit,
        submission_count,
        accepted_count,
        ROUND(
        CASE
        WHEN submission_count &gt; 0
        THEN (accepted_count * 100.0 / submission_count)
        ELSE 0
        END, 2
        ) as acceptance_rate,
        -- 性能指标
        ROUND(time_limit / 1000.0, 2) as time_limit_seconds,
        memory_limit as memory_limit_mb,
        -- 相对性能指标
        ROUND(
        time_limit / (
        SELECT AVG(time_limit)
        FROM problem
        WHERE is_deleted = 0 AND difficulty = p.difficulty
        ), 2
        ) as time_limit_ratio_to_avg,
        ROUND(
        memory_limit / (
        SELECT AVG(memory_limit)
        FROM problem
        WHERE is_deleted = 0 AND difficulty = p.difficulty
        ), 2
        ) as memory_limit_ratio_to_avg,
        -- 效率评分
        ROUND(
        (accepted_count * 1.0 / GREATEST(submission_count, 1)) * 100 /
        (time_limit / 1000.0) * 10
        , 2) as time_efficiency_score,
        ROUND(
        (accepted_count * 1.0 / GREATEST(submission_count, 1)) * 100 /
        memory_limit * 1000
        , 2) as memory_efficiency_score
        FROM problem p
        WHERE p.is_deleted = 0 AND p.status = 1
        ORDER BY time_efficiency_score DESC
        <if test="limit != null">
            LIMIT #{limit}
        </if>
    </select>

    <!-- 获取资源使用效率分析 -->
    <select id="getResourceUsageEfficiencyAnalysis" resultType="java.util.HashMap">
        SELECT
            -- 时间限制分析
            ROUND(AVG(time_limit), 2)   as avg_time_limit,
            MIN(time_limit)             as min_time_limit,
            MAX(time_limit)             as max_time_limit,
            STDDEV(time_limit)          as time_limit_stddev,
            -- 内存限制分析
            ROUND(AVG(memory_limit), 2) as avg_memory_limit,
            MIN(memory_limit)           as min_memory_limit,
            MAX(memory_limit)           as max_memory_limit,
            STDDEV(memory_limit)        as memory_limit_stddev,
            -- 效率指标
            ROUND(AVG(
                          CASE
                              WHEN submission_count &gt; 0
                                  THEN (accepted_count * 1.0 / submission_count)
                              ELSE 0
                              END
                  ), 4)                 as avg_acceptance_rate,
            ROUND(AVG(
                          CASE
                              WHEN submission_count &gt; 0
                                  THEN (accepted_count * 1.0 / submission_count) / (time_limit / 1000.0)
                              ELSE 0
                              END
                  ), 6)                 as avg_time_efficiency,
            ROUND(AVG(
                          CASE
                              WHEN submission_count &gt; 0
                                  THEN (accepted_count * 1.0 / submission_count) / memory_limit
                              ELSE 0
                              END
                  ), 6)                 as avg_memory_efficiency
        FROM problem
        WHERE is_deleted = 0
          AND status = 1
        GROUP BY problem_type, difficulty
        ORDER BY problem_type, difficulty
    </select>

    <!-- 获取题目响应时间分析 -->
    <select id="getProblemResponseTimeAnalysis" resultType="java.util.HashMap">
        SELECT
        id,
        title,
        difficulty,
        problem_type,
        time_limit,
        submission_count,
        accepted_count,
        created_at,
        updated_at,
        DATEDIFF(updated_at, created_at) as maintenance_days,
        DATEDIFF(CURRENT_DATE, created_at) as age_days,
        -- 响应性指标
        CASE
        WHEN DATEDIFF(updated_at, created_at) = 0 THEN 'NO_MAINTENANCE'
        WHEN DATEDIFF(updated_at, created_at) &lt;= 7 THEN 'QUICK_RESPONSE'
        WHEN DATEDIFF(updated_at, created_at) &lt;= 30 THEN 'NORMAL_RESPONSE'
        WHEN DATEDIFF(updated_at, created_at) &lt;= 90 THEN 'SLOW_RESPONSE'
        ELSE 'VERY_SLOW_RESPONSE'
        END as response_category,
        -- 维护频率
        ROUND(
        DATEDIFF(updated_at, created_at) * 1.0 /
        GREATEST(DATEDIFF(CURRENT_DATE, created_at), 1)
        , 4) as maintenance_frequency
        FROM problem
        WHERE is_deleted = 0 AND status = 1
        <if test="timeRange != null">
            AND created_at &gt;= DATE_SUB(CURRENT_DATE, INTERVAL #{timeRange} DAY)
        </if>
        ORDER BY maintenance_frequency DESC, submission_count DESC
    </select>

    <!-- V2版本：综合分析聚合接口 -->

    <!-- 获取题目综合健康度报告 -->
    <select id="getProblemHealthReport" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                                         as total_problems,
               COUNT(CASE WHEN status = 1 THEN 1 END)                                           as active_problems,
               COUNT(CASE WHEN submission_count = 0 THEN 1 END)                                 as zero_submission_problems,
               COUNT(CASE WHEN submission_count &gt; 0 AND accepted_count = 0 THEN 1 END)       as unsolvable_problems,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) &gt; 90 THEN 1 END)           as stale_problems,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 30 THEN 1 END)          as recent_problems,
               -- 健康度指标
               ROUND(COUNT(CASE WHEN status = 1 THEN 1 END) * 100.0 / COUNT(*), 2)              as active_rate,
               ROUND(COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) * 100.0 / COUNT(*), 2) as engagement_rate,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ),
                     2)                                                                         as overall_acceptance_rate,
               -- 生态多样性
               COUNT(DISTINCT creator_id)                                                       as unique_creators,
               COUNT(DISTINCT problem_type)                                                     as unique_types,
               COUNT(DISTINCT difficulty)                                                       as unique_difficulties,
               COUNT(DISTINCT supported_languages)                                              as unique_language_sets,
               -- 质量指标
               COUNT(CASE
                         WHEN submission_count &gt; 10 AND (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 80
                             THEN 1 END)                                                        as quality_problems,
               ROUND(AVG(time_limit), 2)                                                        as avg_time_limit,
               ROUND(AVG(memory_limit), 2)                                                      as avg_memory_limit,
               -- 综合健康评分 (0-100)
               ROUND(
                       COUNT(CASE WHEN status = 1 THEN 1 END) * 25.0 / COUNT(*) +
                       COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) * 25.0 / COUNT(*) +
                       COUNT(CASE
                                 WHEN submission_count &gt; 10 AND
                                      (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 80 THEN 1 END) * 30.0 /
                       COUNT(*) +
                       COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 90 THEN 1 END) * 20.0 / COUNT(*)
                   , 2)                                                                         as health_score
        FROM problem
        WHERE is_deleted = 0
    </select>

    <!-- 获取题目标签云数据 -->
    <select id="getTagCloudData" resultType="java.util.HashMap">
        SELECT
        problem_type as tag_name,
        COUNT(*) as tag_count,
        SUM(submission_count) as total_submissions,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as usage_percentage,
        -- 标签权重（用于标签云大小）
        ROUND(
        COUNT(*) * 0.6 +
        SUM(submission_count) * 0.001 +
        COUNT(CASE WHEN status = 1 THEN 1 END) * 0.4
        , 2) as tag_weight
        FROM problem
        WHERE is_deleted = 0 AND problem_type IS NOT NULL
        GROUP BY problem_type
        UNION ALL
        SELECT
        difficulty as tag_name,
        COUNT(*) as tag_count,
        SUM(submission_count) as total_submissions,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as usage_percentage,
        ROUND(
        COUNT(*) * 0.6 +
        SUM(submission_count) * 0.001 +
        COUNT(CASE WHEN status = 1 THEN 1 END) * 0.4
        , 2) as tag_weight
        FROM problem
        WHERE is_deleted = 0 AND difficulty IS NOT NULL
        GROUP BY difficulty
        ORDER BY tag_weight DESC
        <if test="limit != null">
            LIMIT #{limit}
        </if>
    </select>

    <!-- 获取平台竞争力分析 -->
    <select id="getPlatformCompetitivenessAnalysis" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                                as total_problem_inventory,
               COUNT(CASE WHEN status = 1 THEN 1 END)                                  as available_problems,
               COUNT(DISTINCT creator_id)                                              as contributor_count,
               COUNT(DISTINCT problem_type)                                            as problem_type_diversity,
               SUM(submission_count)                                                   as total_user_engagement,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ), 2)                                                             as platform_success_rate,
               -- 内容丰富度
               COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)                         as beginner_friendly_count,
               COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                         as advanced_challenge_count,
               -- 活跃度指标
               COUNT(CASE WHEN submission_count &gt; 50 THEN 1 END)                    as highly_engaged_problems,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 30 THEN 1 END) as recent_content_additions,
               -- 质量指标
               COUNT(CASE
                         WHEN submission_count &gt; 10 AND (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 80
                             THEN 1 END)                                               as balanced_difficulty_problems,
               -- 综合竞争力评分 (0-100)
               ROUND(
                   -- 内容丰富度 (25%)
                       LEAST(COUNT(*) / 1000.0, 1) * 25 +
                           -- 用户参与度 (25%)
                       LEAST(SUM(submission_count) / 10000.0, 1) * 25 +
                           -- 内容质量 (25%)
                       COUNT(CASE
                                 WHEN submission_count &gt; 10 AND
                                      (accepted_count * 100.0 / submission_count) BETWEEN 20 AND 80 THEN 1 END) * 25.0 /
                       COUNT(*) +
                           -- 活跃度和更新频率 (25%)
                       COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 90 THEN 1 END) * 25.0 / COUNT(*)
                   , 2)                                                                as competitiveness_score
        FROM problem
        WHERE is_deleted = 0
    </select>

    <!-- 获取题目生态健康度指标 -->
    <select id="getProblemEcosystemHealth" resultType="java.util.HashMap">
        SELECT
            -- 多样性指标
            COUNT(DISTINCT creator_id)                                              as creator_diversity,
            COUNT(DISTINCT problem_type)                                            as type_diversity,
            COUNT(DISTINCT difficulty)                                              as difficulty_diversity,
            COUNT(DISTINCT supported_languages)                                     as language_diversity,
            -- 活跃度指标
            COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END)                     as engaged_problems,
            COUNT(CASE WHEN submission_count &gt; 10 THEN 1 END)                    as moderately_popular_problems,
            COUNT(CASE WHEN submission_count &gt; 50 THEN 1 END)                    as highly_popular_problems,
            -- 新鲜度指标
            COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 7 THEN 1 END)  as problems_created_last_7_days,
            COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 30 THEN 1 END) as problems_created_last_month,
            COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) &lt;= 30 THEN 1 END) as problems_updated_last_month,
            -- 维护度指标
            COUNT(CASE WHEN DATEDIFF(updated_at, created_at) &gt; 0 THEN 1 END)     as maintained_problems,
            COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) &gt; 90 THEN 1 END)  as stale_problems,
            -- 平衡性指标
            COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)                         as easy_balance,
            COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END)                       as medium_balance,
            COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                         as hard_balance,
            -- 综合生态健康评分 (0-100)
            ROUND(
                -- 多样性 (30%)
                    (COUNT(DISTINCT creator_id) / GREATEST(COUNT(*) / 10.0, 1)) * 30 * 0.25 +
                    (COUNT(DISTINCT problem_type) / 10.0) * 30 * 0.25 +
                    (COUNT(DISTINCT difficulty) / 3.0) * 30 * 0.25 +
                    (COUNT(DISTINCT supported_languages) / 20.0) * 30 * 0.25 +
                        -- 活跃度 (25%)
                    COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) * 25.0 / COUNT(*) +
                        -- 新鲜度 (25%)
                    COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 30 THEN 1 END) * 25.0 / COUNT(*) +
                        -- 维护度 (20%)
                    COUNT(CASE WHEN DATEDIFF(updated_at, created_at) &gt; 0 THEN 1 END) * 20.0 / COUNT(*)
                , 2)                                                                as ecosystem_health_score
        FROM problem
        WHERE is_deleted = 0
    </select>

    <!-- V2版本：高级聚合分析接口 -->

    <!-- 获取题目相关性分析（基于用户行为） -->
    <select id="getProblemCorrelationAnalysis" resultType="java.util.HashMap">
        SELECT
        p2.id as related_problem_id,
        p2.title as related_title,
        p2.difficulty as related_difficulty,
        p2.problem_type as related_type,
        p2.submission_count as related_submissions,
        p2.accepted_count as related_accepted,
        ROUND(
        CASE
        WHEN p2.submission_count &gt; 0
        THEN (p2.accepted_count * 100.0 / p2.submission_count)
        ELSE 0
        END, 2
        ) as related_acceptance_rate,
        -- 相关性评分（基于题目属性相似度）
        ROUND(
        -- 难度相似性 (30%)
        (CASE WHEN p1.difficulty = p2.difficulty THEN 30 ELSE 10 END) +
        -- 类型相似性 (25%)
        (CASE WHEN p1.problem_type = p2.problem_type THEN 25 ELSE 0 END) +
        -- 时间限制相似性 (15%)
        (15 - ABS(p1.time_limit - p2.time_limit) / 1000.0 * 5) +
        -- 内存限制相似性 (15%)
        (15 - ABS(p1.memory_limit - p2.memory_limit) / 100.0 * 5) +
        -- 通过率相似性 (15%)
        (15 - ABS(
        (CASE WHEN p1.submission_count &gt; 0 THEN p1.accepted_count * 100.0 / p1.submission_count ELSE 0 END) -
        (CASE WHEN p2.submission_count &gt; 0 THEN p2.accepted_count * 100.0 / p2.submission_count ELSE 0 END)
        ) * 0.3)
        , 2) as correlation_score
        FROM problem p1
        CROSS JOIN problem p2
        WHERE p1.id = #{problemId}
        AND p2.id != #{problemId}
        AND p1.is_deleted = 0 AND p2.is_deleted = 0
        AND p1.status = 1 AND p2.status = 1
        ORDER BY correlation_score DESC
        <if test="limit != null">
            LIMIT #{limit}
        </if>
    </select>

    <!-- 获取题目难度预测数据 -->
    <select id="getDifficultyPredictionData" resultType="java.util.HashMap">
        SELECT id,
               title,
               difficulty as labeled_difficulty,
               problem_type,
               time_limit,
               memory_limit,
               submission_count,
               accepted_count,
               ROUND(
                       CASE
                           WHEN submission_count &gt; 0
                               THEN (accepted_count * 100.0 / submission_count)
                           ELSE 0
                           END, 2
               )          as actual_acceptance_rate,
               -- 预测难度基于多个因素
               CASE
                   WHEN submission_count = 0 THEN 'UNKNOWN'
                   WHEN (accepted_count * 100.0 / submission_count) &gt;= 70 THEN 'PREDICTED_EASY'
                   WHEN (accepted_count * 100.0 / submission_count) &gt;= 40 THEN 'PREDICTED_MEDIUM'
                   ELSE 'PREDICTED_HARD'
                   END    as predicted_difficulty_by_acceptance,
               -- 基于时间限制的难度预测
               CASE
                   WHEN time_limit &lt; 2000 THEN 'TIME_CONSTRAINT_HARD'
                   WHEN time_limit &lt; 5000 THEN 'TIME_CONSTRAINT_MEDIUM'
                   ELSE 'TIME_CONSTRAINT_EASY'
                   END    as predicted_difficulty_by_time,
               -- 基于内存限制的难度预测
               CASE
                   WHEN memory_limit &lt; 128 THEN 'MEMORY_CONSTRAINT_HARD'
                   WHEN memory_limit &lt; 256 THEN 'MEMORY_CONSTRAINT_MEDIUM'
                   ELSE 'MEMORY_CONSTRAINT_EASY'
                   END    as predicted_difficulty_by_memory,
               -- 综合难度预测评分
               ROUND(
                   -- 通过率因子 (50%)
                       (CASE
                            WHEN submission_count = 0 THEN 50
                            WHEN (accepted_count * 100.0 / submission_count) &gt;= 70 THEN 20
                            WHEN (accepted_count * 100.0 / submission_count) &gt;= 40 THEN 50
                            ELSE 80
                           END) * 0.5 +
                           -- 时间限制因子 (25%)
                       (CASE
                            WHEN time_limit &lt; 2000 THEN 80
                            WHEN time_limit &lt; 5000 THEN 50
                            ELSE 20
                           END) * 0.25 +
                           -- 内存限制因子 (15%)
                       (CASE
                            WHEN memory_limit &lt; 128 THEN 80
                            WHEN memory_limit &lt; 256 THEN 50
                            ELSE 20
                           END) * 0.15 +
                           -- 提交量因子 (10%)
                       (CASE
                            WHEN submission_count &gt; 100 THEN 30
                            WHEN submission_count &gt; 50 THEN 50
                            WHEN submission_count &gt; 10 THEN 60
                            ELSE 70
                           END) * 0.1
                   , 2)   as predicted_difficulty_score,
               -- 难度预测准确性分析
               CASE
                   WHEN difficulty = 'EASY' AND (accepted_count * 100.0 / GREATEST(submission_count, 1)) &gt;= 60
                       THEN 'ACCURATE'
                   WHEN difficulty = 'MEDIUM' AND
                        (accepted_count * 100.0 / GREATEST(submission_count, 1)) BETWEEN 30 AND 70 THEN 'ACCURATE'
                   WHEN difficulty = 'HARD' AND (accepted_count * 100.0 / GREATEST(submission_count, 1)) &lt;= 40
                       THEN 'ACCURATE'
                   WHEN submission_count = 0 THEN 'INSUFFICIENT_DATA'
                   ELSE 'INACCURATE'
                   END    as difficulty_label_accuracy
        FROM problem
        WHERE id = #{problemId}
          AND is_deleted = 0
    </select>

    <!-- 获取实时题目状态监控 -->
    <select id="getRealTimeProblemStatus" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                                         as total_active_problems,
               COUNT(CASE WHEN submission_count = 0 THEN 1 END)                                 as problems_needing_attention,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) &gt; 30 THEN 1 END)           as stale_problems,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, created_at) &lt;= 1 THEN 1 END)           as new_problems_last_24h,
               COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) &lt;= 1 THEN 1 END)           as updated_problems_last_24h,
               SUM(submission_count)                                                            as total_submissions_today,
               SUM(accepted_count)                                                              as total_accepted_today,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ),
                     2)                                                                         as current_average_acceptance_rate,
               -- 系统健康指标
               ROUND(COUNT(CASE WHEN status = 1 THEN 1 END) * 100.0 / COUNT(*), 2)              as system_availability,
               ROUND(COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) * 100.0 / COUNT(*), 2) as engagement_rate,
               -- 实时状态
               NOW()                                                                            as snapshot_time
        FROM problem
        WHERE is_deleted = 0
          AND status = 1
    </select>

    <!-- V2版本：分布分析聚合接口 -->

    <!-- 获取难度-类型分布矩阵 -->
    <select id="getDifficultyTypeDistribution" resultType="java.util.HashMap">
        SELECT difficulty,
               problem_type,
               COUNT(*)                                                                         as problem_count,
               COUNT(CASE WHEN status = 1 THEN 1 END)                                           as active_count,
               SUM(submission_count)                                                            as total_submissions,
               SUM(accepted_count)                                                              as total_accepted,
               ROUND(
                       CASE
                           WHEN SUM(submission_count) &gt; 0
                               THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                           ELSE 0
                           END, 2
               )                                                                                as acceptance_rate,
               ROUND(AVG(time_limit), 2)                                                        as avg_time_limit,
               ROUND(AVG(memory_limit), 2)                                                      as avg_memory_limit,
               -- 分布百分比
               ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as percentage
        FROM problem
        WHERE is_deleted = 0
        GROUP BY difficulty, problem_type
        ORDER BY CASE difficulty
                     WHEN 'EASY' THEN 1
                     WHEN 'MEDIUM' THEN 2
                     WHEN 'HARD' THEN 3
                     ELSE 4
                     END,
                 problem_type
    </select>

    <!-- 获取通过率分布统计 -->
    <select id="getAcceptanceRateDistribution" resultType="java.util.HashMap">
        SELECT
        <choose>
            <when test="bucketSize != null">
                CONCAT(
                FLOOR((accepted_count * 100.0 / NULLIF(submission_count, 0)) / (#{bucketSize} * 100)) * (#{bucketSize} *
                100),
                '-',
                (FLOOR((accepted_count * 100.0 / NULLIF(submission_count, 0)) / (#{bucketSize} * 100)) + 1) *
                (#{bucketSize} * 100)
                ) as acceptance_rate_range,
                FLOOR((accepted_count * 100.0 / NULLIF(submission_count, 0)) / (#{bucketSize} * 100)) * (#{bucketSize} *
                100) as range_start
            </when>
            <otherwise>
                CASE
                WHEN submission_count = 0 THEN '0%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 10 THEN '0-10%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 20 THEN '10-20%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 30 THEN '20-30%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 40 THEN '30-40%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 50 THEN '40-50%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 60 THEN '50-60%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 70 THEN '60-70%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 80 THEN '70-80%'
                WHEN (accepted_count * 100.0 / submission_count) &lt; 90 THEN '80-90%'
                ELSE '90-100%'
                END as acceptance_rate_range,
                CASE
                WHEN submission_count = 0 THEN 0
                WHEN (accepted_count * 100.0 / submission_count) &lt; 10 THEN 0
                WHEN (accepted_count * 100.0 / submission_count) &lt; 20 THEN 10

                WHEN (accepted_count * 100.0 / submission_count) &lt; 30 THEN 20
                WHEN (accepted_count * 100.0 / submission_count) &lt; 40 THEN 30
                WHEN (accepted_count * 100.0 / submission_count) &lt; 50 THEN 40
                WHEN (accepted_count * 100.0 / submission_count) &lt; 60 THEN 50
                WHEN (accepted_count * 100.0 / submission_count) &lt; 70 THEN 60
                WHEN (accepted_count * 100.0 / submission_count) &lt; 80 THEN 70
                WHEN (accepted_count * 100.0 / submission_count) &lt; 90 THEN 80
                ELSE 90
                END as range_start
            </otherwise>
        </choose>
        ,
        COUNT(*) as problem_count,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0 AND submission_count > 0), 2) as
        percentage
        FROM problem
        WHERE is_deleted = 0 AND submission_count &gt; 0
        GROUP BY acceptance_rate_range, range_start
        ORDER BY range_start
    </select>

    <!-- 获取提交量分布统计 -->
    <select id="getSubmissionCountDistribution" resultType="java.util.HashMap">
        SELECT CASE
                   WHEN submission_count = 0 THEN '0'
                   WHEN submission_count BETWEEN 1 AND 5 THEN '1-5'
                   WHEN submission_count BETWEEN 6 AND 10 THEN '6-10'
                   WHEN submission_count BETWEEN 11 AND 20 THEN '11-20'
                   WHEN submission_count BETWEEN 21 AND 50 THEN '21-50'
                   WHEN submission_count BETWEEN 51 AND 100 THEN '51-100'
                   WHEN submission_count BETWEEN 101 AND 200 THEN '101-200'
                   WHEN submission_count BETWEEN 201 AND 500 THEN '201-500'
                   WHEN submission_count BETWEEN 501 AND 1000 THEN '501-1000'
                   ELSE '1000+'
                   END                                                                          as submission_range,
               CASE
                   WHEN submission_count = 0 THEN 0
                   WHEN submission_count BETWEEN 1 AND 5 THEN 1
                   WHEN submission_count BETWEEN 6 AND 10 THEN 6
                   WHEN submission_count BETWEEN 11 AND 20 THEN 11
                   WHEN submission_count BETWEEN 21 AND 50 THEN 21
                   WHEN submission_count BETWEEN 51 AND 100 THEN 51
                   WHEN submission_count BETWEEN 101 AND 200 THEN 101
                   WHEN submission_count BETWEEN 201 AND 500 THEN 201
                   WHEN submission_count BETWEEN 501 AND 1000 THEN 501
                   ELSE 1000
                   END                                                                          as range_start,
               COUNT(*)                                                                         as problem_count,
               ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as percentage,
               SUM(submission_count)                                                            as total_submissions_in_range,
               SUM(accepted_count)                                                              as total_accepted_in_range
        FROM problem
        WHERE is_deleted = 0
        GROUP BY submission_range, range_start
        ORDER BY range_start
    </select>

    <!-- 获取题目时间限制分布 -->
    <select id="getTimeLimitDistribution" resultType="java.util.HashMap">
        SELECT CASE
                   WHEN time_limit &lt; 1000 THEN '&lt;1s'
                   WHEN time_limit BETWEEN 1000 AND 2000 THEN '1-2s'
                   WHEN time_limit BETWEEN 2001 AND 5000 THEN '2-5s'
                   WHEN time_limit BETWEEN 5001 AND 10000 THEN '5-10s'
                   WHEN time_limit BETWEEN 10001 AND 30000 THEN '10-30s'
                   ELSE '&gt;30s'
                   END                                                                          as time_limit_range,
               CASE
                   WHEN time_limit &lt; 1000 THEN 0
                   WHEN time_limit BETWEEN 1000 AND 2000 THEN 1000
                   WHEN time_limit BETWEEN 2001 AND 5000 THEN 2001
                   WHEN time_limit BETWEEN 5001 AND 10000 THEN 5001
                   WHEN time_limit BETWEEN 10001 AND 30000 THEN 10001
                   ELSE 30001
                   END                                                                          as range_start,
               COUNT(*)                                                                         as problem_count,
               ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as percentage,
               MIN(time_limit)                                                                  as min_time_limit,
               MAX(time_limit)                                                                  as max_time_limit,
               ROUND(AVG(time_limit), 2)                                                        as avg_time_limit
        FROM problem
        WHERE is_deleted = 0
          AND time_limit IS NOT NULL
        GROUP BY time_limit_range, range_start
        ORDER BY range_start
    </select>

    <!-- 获取题目内存限制分布 -->
    <select id="getMemoryLimitDistribution" resultType="java.util.HashMap">
        SELECT CASE
                   WHEN memory_limit &lt; 64 THEN '&lt;64MB'
                   WHEN memory_limit BETWEEN 64 AND 128 THEN '64-128MB'
                   WHEN memory_limit BETWEEN 129 AND 256 THEN '128-256MB'
                   WHEN memory_limit BETWEEN 257 AND 512 THEN '256-512MB'
                   WHEN memory_limit BETWEEN 513 AND 1024 THEN '512MB-1GB'
                   ELSE '&gt;1GB'
                   END                                                                          as memory_limit_range,
               CASE
                   WHEN memory_limit &lt; 64 THEN 0
                   WHEN memory_limit BETWEEN 64 AND 128 THEN 64
                   WHEN memory_limit BETWEEN 129 AND 256 THEN 129
                   WHEN memory_limit BETWEEN 257 AND 512 THEN 257
                   WHEN memory_limit BETWEEN 513 AND 1024 THEN 513
                   ELSE 1025
                   END                                                                          as range_start,
               COUNT(*)                                                                         as problem_count,
               ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as percentage,
               MIN(memory_limit)                                                                as min_memory_limit,
               MAX(memory_limit)                                                                as max_memory_limit,
               ROUND(AVG(memory_limit), 2)                                                      as avg_memory_limit
        FROM problem
        WHERE is_deleted = 0
          AND memory_limit IS NOT NULL
        GROUP BY memory_limit_range, range_start
        ORDER BY range_start
    </select>

    <!-- 获取题目可见性分布 -->
    <select id="getVisibilityDistribution" resultType="java.util.HashMap">
        SELECT visibility,
               CASE
                   WHEN visibility = 1 THEN 'PUBLIC'
                   WHEN visibility = 0 THEN 'PRIVATE'
                   ELSE 'UNKNOWN'
                   END                                                                          as visibility_name,
               COUNT(*)                                                                         as problem_count,
               ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM problem WHERE is_deleted = 0), 2) as percentage,
               COUNT(CASE WHEN status = 1 THEN 1 END)                                           as active_problems,
               SUM(submission_count)                                                            as total_submissions,
               SUM(accepted_count)                                                              as total_accepted,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ), 2)                                                                      as avg_acceptance_rate
        FROM problem
        WHERE is_deleted = 0
        GROUP BY visibility
        ORDER BY visibility DESC
    </select>

    <!-- 获取编程语言使用分布 -->
    <select id="getLanguageUsageDistribution" resultType="java.util.HashMap">
        SELECT supported_languages,
               COUNT(*)                                          as problem_count,
               ROUND(COUNT(*) * 100.0 /
                     (SELECT COUNT(*) FROM problem WHERE is_deleted = 0 AND supported_languages IS NOT NULL),
                     2)                                          as percentage,
               COUNT(CASE WHEN status = 1 THEN 1 END)            as active_problems,
               SUM(submission_count)                             as total_submissions,
               SUM(accepted_count)                               as total_accepted,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ),
                     2)                                          as avg_acceptance_rate,
               -- 难度分布
               COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)   as easy_problems,
               COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
               COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)   as hard_problems
        FROM problem
        WHERE is_deleted = 0
          AND supported_languages IS NOT NULL
        GROUP BY supported_languages
        ORDER BY problem_count DESC
    </select>

<!-- 获取题目生命周期分析 -->
<select id="getProblemLifecycleAnalysis" resultType="java.util.HashMap">
    SELECT p.id                           as problem_id,
           p.title,
           p.created_at,
           p.updated_at                   as update_time,
           DATEDIFF(NOW(), p.created_at) as days_since_creation,
           p.submission_count,
           p.accepted_count,
           -- 移除 view_count 相关统计，使用其他指标代替
           0                              as view_count,
           -- 生命周期阶段
           CASE
               WHEN DATEDIFF(NOW(), p.created_at) &lt;= 7 THEN 'NEW'
               WHEN DATEDIFF(NOW(), p.created_at) &lt;= 30 THEN 'GROWING'
               WHEN DATEDIFF(NOW(), p.created_at) &lt;= 90 THEN 'MATURE'
               WHEN DATEDIFF(NOW(), p.created_at) &lt;= 365 THEN 'STABLE'
               ELSE 'LEGACY'
               END                        as lifecycle_stage,
           -- 活跃度评分（调整计算方式，移除 view_count）
           ROUND(
                   (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                   GREATEST(DATEDIFF(NOW(), p.created_at), 1), 2
           )                              as activity_score,
           -- 健康度评分
           ROUND(
                   CASE
                       WHEN p.submission_count = 0 THEN 0
                       ELSE (p.accepted_count * 100.0 / p.submission_count) * 0.6 +
                            LEAST(p.submission_count / 100.0, 1) * 40
                       END, 2
           )                              as health_score
    FROM problem p
    WHERE p.is_deleted = 0
      AND p.id = #{problemId}
</select>



<!-- 获取平台增长指标 -->
<select id="getPlatformGrowthMetrics" resultType="java.util.HashMap">
    SELECT COUNT(*)                                                                                 as total_problems,
           COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL #{timeRange} DAY) THEN 1 END) as new_problems,
           SUM(submission_count)                                                                    as total_submissions,
           SUM(accepted_count)                                                                      as total_accepted,
           -- 移除 view_count 相关统计
           0                                                                                        as total_views,
           -- 增长率计算
           ROUND(
                   COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL #{timeRange} DAY) THEN 1 END) *
                   100.0 /
                   GREATEST(COUNT(CASE WHEN created_at &lt; DATE_SUB(NOW(), INTERVAL #{timeRange} DAY) THEN 1 END),
                            1), 2
           )                                                                                        as problem_growth_rate,
           -- 活跃度指标
           ROUND(AVG(submission_count), 2)                                                          as avg_submissions_per_problem,
           -- 移除 view_count 相关统计
           0                                                                                        as avg_views_per_problem,
           -- 质量指标
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ),
                 2)                                                                                 as platform_acceptance_rate,
           -- 创新指标
           COUNT(DISTINCT creator_id)                                                               as active_creators,
           COUNT(DISTINCT supported_languages)                                                      as language_diversity
    FROM problem
    WHERE is_deleted = 0
</select>

<!-- 获取题目集群分析 -->
<select id="getProblemClusterAnalysis" resultType="java.util.HashMap">
    SELECT p.difficulty,
           p.problem_type,
           COUNT(*)                          as cluster_size,
           ROUND(AVG(p.submission_count), 2) as avg_submissions,
           ROUND(AVG(p.accepted_count), 2)   as avg_accepted,
           -- 移除 view_count 相关统计
           0                                 as avg_views,
           ROUND(AVG(
                         CASE
                             WHEN p.submission_count > 0
                                 THEN (p.accepted_count * 100.0 / p.submission_count)
                             ELSE 0
                             END
                 ), 2)                       as avg_acceptance_rate,
           -- 聚类特征
           MIN(p.time_limit)                 as min_time_limit,
           MAX(p.time_limit)                 as max_time_limit,
           MIN(p.memory_limit)               as min_memory_limit,
           MAX(p.memory_limit)               as max_memory_limit,
           -- 聚类健康度（调整计算方式）
           ROUND(
                   (AVG(p.submission_count) * 0.5 +
                    AVG(CASE
                            WHEN p.submission_count > 0 THEN (p.accepted_count * 100.0 / p.submission_count)
                            ELSE 0 END) * 0.5), 2
           )                                 as cluster_health_score
    FROM problem p
    WHERE p.is_deleted = 0
    GROUP BY p.difficulty, p.problem_type
    HAVING COUNT(*) >= #{clusterCount}
    ORDER BY cluster_health_score DESC
</select>

    <!-- 获取题目异常检测分析 -->
    <select id="getProblemAnomalyDetection" resultType="java.util.HashMap">
        SELECT p.id    as problem_id,
               p.title,
               p.difficulty,
               p.submission_count,
               p.accepted_count,
               p.view_count,
               -- 异常类型检测
               CASE
                   WHEN p.submission_count = 0 AND DATEDIFF(NOW(), p.created_at) &gt; 30 THEN 'ZERO_SUBMISSION'
                   WHEN p.submission_count &gt; 0 AND (p.accepted_count * 100.0 / p.submission_count) &lt; 5
                       THEN 'EXTREMELY_HARD'
                   WHEN p.submission_count &gt; 0 AND (p.accepted_count * 100.0 / p.submission_count) &gt; 95
                       THEN 'EXTREMELY_EASY'
                   WHEN p.view_count &gt; 0 AND (p.submission_count * 100.0 / p.view_count) &lt; 1 THEN 'LOW_ENGAGEMENT'
                   WHEN p.submission_count &gt; (SELECT AVG(submission_count) * 10 FROM problem WHERE is_deleted = 0)
                       THEN 'ABNORMALLY_POPULAR'
                   ELSE 'NORMAL'
                   END as anomaly_type,
               -- 异常评分
               ROUND(
                       ABS(
                               (p.submission_count - (SELECT AVG(submission_count) FROM problem WHERE is_deleted = 0)) /
                               GREATEST((SELECT STDDEV(submission_count) FROM problem WHERE is_deleted = 0), 1)
                       ), 2
               )       as anomaly_score,
               -- 建议措施
               CASE
                   WHEN p.submission_count = 0 AND DATEDIFF(NOW(), p.created_at) &gt; 30 THEN 'PROMOTE_PROBLEM'
                   WHEN p.submission_count &gt; 0 AND (p.accepted_count * 100.0 / p.submission_count) &lt; 5
                       THEN 'REVIEW_DIFFICULTY'
                   WHEN p.submission_count &gt; 0 AND (p.accepted_count * 100.0 / p.submission_count) &gt; 95
                       THEN 'INCREASE_DIFFICULTY'
                   WHEN p.view_count &gt; 0 AND (p.submission_count * 100.0 / p.view_count) &lt; 1
                       THEN 'IMPROVE_DESCRIPTION'
                   ELSE 'NO_ACTION_NEEDED'
                   END as suggested_action
        FROM problem p
        WHERE p.is_deleted = 0
        HAVING anomaly_type != 'NORMAL'
        ORDER BY anomaly_score DESC
    </select>

<!-- 获取题目月度报表数据 -->
<select id="getMonthlyReport" resultType="java.util.HashMap">
    SELECT #{year}                                                                                    as report_year,
           #{month}                                                                                   as report_month,
           COUNT(*)                                                                                   as total_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND MONTH(created_at) = #{month} THEN 1 END) as new_problems_this_month,
           SUM(submission_count)                                                                      as total_submissions,
           SUM(accepted_count)                                                                        as total_accepted,
           -- 移除 view_count 相关统计
           0                                                                                          as total_views,
           -- 按难度统计
           COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)                                            as easy_problems,
           COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END)                                          as medium_problems,
           COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                                            as hard_problems,
           -- 质量指标
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ),
                 2)                                                                                   as avg_acceptance_rate,
           -- 活跃度指标
           COUNT(CASE WHEN submission_count > 0 THEN 1 END)                                        as active_problems,
           COUNT(CASE WHEN submission_count = 0 THEN 1 END)                                           as inactive_problems,
           -- 创建者活跃度
           COUNT(DISTINCT creator_id)                                                                 as active_creators,
           -- 平台健康度
           ROUND(
                   (COUNT(CASE WHEN submission_count > 0 THEN 1 END) * 100.0 / COUNT(*)), 2
           )                                                                                          as platform_activity_rate
    FROM problem
    WHERE is_deleted = 0
</select>

<!-- 获取题目年度报表数据 -->
<select id="getAnnualReport" resultType="java.util.HashMap">
    SELECT #{year}                                                                               as       report_year,
           COUNT(*)                                                                              as       total_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} THEN 1 END)                              as       new_problems_this_year,
           SUM(submission_count)                                                                 as       total_submissions,
           SUM(accepted_count)                                                                   as       total_accepted,
           -- 移除 view_count 相关统计
           0                                                                                     as       total_views,
           -- 月度增长趋势
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = 1 THEN 1 END) as       q1_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = 2 THEN 1 END) as       q2_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = 3 THEN 1 END) as       q3_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = 4 THEN 1 END) as       q4_problems,
           -- 年度质量指标
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ),
                 2)                                                                              as       annual_acceptance_rate,
           -- 年度创新指标
           COUNT(DISTINCT creator_id)                                                            as       total_creators,
           COUNT(DISTINCT supported_languages)                                                   as       language_diversity,
           COUNT(DISTINCT problem_type)                                                          as       type_diversity,
           -- 年度成就
           MAX(submission_count)                                                                 as       max_submissions,
           -- 移除 view_count 相关统计
           0                                                                                     as       max_views,
           (SELECT title FROM problem WHERE is_deleted = 0 AND submission_count = MAX(p.submission_count) LIMIT 1) as most_popular_problem
    FROM problem p
    WHERE is_deleted = 0
</select>


<!-- 获取自定义时间范围统计报表 -->
<select id="getCustomRangeReport" resultType="java.util.HashMap">
    SELECT COUNT(*)                                                                   as total_problems,
           COUNT(CASE WHEN created_at BETWEEN #{startDate} AND #{endDate} THEN 1 END) as problems_in_range,
           SUM(submission_count)                                                      as total_submissions,
           SUM(accepted_count)                                                        as total_accepted,
           0                                                                          as total_views,
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ), 2)                                                                as avg_acceptance_rate,
           COUNT(DISTINCT creator_id)                                                 as unique_creators,
           COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)                            as easy_count,
           COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END)                          as medium_count,
           COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                            as hard_count,
           COUNT(CASE WHEN submission_count > 100 THEN 1 END)                         as high_activity_problems,
           COUNT(CASE WHEN submission_count BETWEEN 10 AND 100 THEN 1 END)            as medium_activity_problems,
           COUNT(CASE WHEN submission_count BETWEEN 1 AND 10 THEN 1 END)              as low_activity_problems,
           COUNT(CASE WHEN submission_count = 0 THEN 1 END)                           as zero_activity_problems
    FROM problem
    WHERE is_deleted = 0
</select>

<!-- 获取周度报表数据 -->
<select id="getWeeklyReport" resultType="java.util.HashMap">
    SELECT #{year}                                                                                   as report_year,
           #{week}                                                                                   as report_week,
           COUNT(*)                                                                                  as total_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND WEEK(created_at, 1) = #{week} THEN 1 END) as new_problems_this_week,
           SUM(submission_count)                                                                     as total_submissions,
           SUM(accepted_count)                                                                       as total_accepted,
           -- 周度活跃度
           ROUND(AVG(submission_count), 2)                                                           as avg_submissions_per_problem,
           -- 移除 view_count 相关统计
           0                                                                                         as avg_views_per_problem,
           -- 周度质量
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ),
                 2)                                                                                  as weekly_acceptance_rate,
           -- 创建者活跃度
           COUNT(DISTINCT creator_id)                                                                as active_creators_count,
           -- 难度分布
           COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END)                                           as easy_problems,
           COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END)                                         as medium_problems,
           COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END)                                           as hard_problems
    FROM problem
    WHERE is_deleted = 0
</select>


<!-- 获取季度报表数据 -->
<select id="getQuarterlyReport" resultType="java.util.HashMap">
    SELECT #{year}                                                                                        as report_year,
           #{quarter}                                                                                     as report_quarter,
           COUNT(*)                                                                                       as total_problems,
           COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = #{quarter} THEN 1 END) as new_problems_this_quarter,
           SUM(submission_count)                                                                          as total_submissions,
           SUM(accepted_count)                                                                            as total_accepted,
           -- 移除 view_count 相关统计
           0                                                                                              as total_views,
           -- 季度增长指标
           ROUND(
                   COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = #{quarter} THEN 1 END) *
                   100.0 /
                   GREATEST(COUNT(CASE WHEN YEAR (created_at) = #{year} AND QUARTER(created_at) = #{quarter} - 1 THEN 1 END), 1),
                   2
           )                                                                                              as quarter_growth_rate,
           -- 季度质量指标
           ROUND(AVG(
                         CASE
                             WHEN submission_count > 0
                                 THEN (accepted_count * 100.0 / submission_count)
                             ELSE 0
                             END
                 ),
                 2)                                                                                       as quarterly_acceptance_rate,
           -- 季度创新指标
           COUNT(DISTINCT creator_id)                                                                     as quarterly_creators,
           COUNT(DISTINCT problem_type)                                                                   as quarterly_types,
           -- 季度热门题目
           (SELECT title FROM problem WHERE is_deleted = 0 AND YEAR (created_at) = #{year} AND QUARTER(created_at) = #{quarter}
    ORDER BY submission_count DESC LIMIT 1) as most_popular_problem_this_quarter
    FROM problem
    WHERE is_deleted = 0
</select>

    <!-- 获取实时提交监控统计 -->
    <select id="getRealTimeSubmissionMonitoring" resultType="java.util.HashMap">
        SELECT COUNT(*)                                            as total_problems,
               SUM(submission_count)                               as total_submissions,
               SUM(accepted_count)                                 as total_accepted,
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ),
                     2)                                            as current_acceptance_rate,
               -- 实时活跃度
               COUNT(CASE
                         WHEN update_time &gt;= DATE_SUB(NOW(), INTERVAL #{timeWindow} MINUTE)
                             THEN 1 END)                           as recently_updated_problems,
               COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) as active_problems,
               COUNT(CASE WHEN submission_count = 0 THEN 1 END)    as inactive_problems,
               -- 实时性能指标
               ROUND(AVG(submission_count), 2)                     as avg_submissions_per_problem,
               MAX(submission_count)                               as max_submissions,
               MIN(submission_count)                               as min_submissions,
               -- 实时健康度
               ROUND(
                       (COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) * 100.0 / COUNT(*)), 2
               )                                                   as platform_health_score
        FROM problem
        WHERE is_deleted = 0
    </select>

    <!-- 获取实时错误率监控 -->
    <select id="getRealTimeErrorRateMonitoring" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                                   as total_problems,
               COUNT(CASE WHEN submission_count = 0 THEN 1 END)                           as zero_submission_problems,
               COUNT(CASE WHEN submission_count &gt; 0 AND accepted_count = 0 THEN 1 END) as zero_acceptance_problems,
               COUNT(CASE
                         WHEN submission_count &gt; 0 AND (accepted_count * 100.0 / submission_count) &lt; 10
                             THEN 1 END)                                                  as high_error_rate_problems,
               -- 错误率分析
               ROUND(
                       COUNT(CASE WHEN submission_count = 0 THEN 1 END) * 100.0 / COUNT(*), 2
               )                                                                          as zero_submission_rate,
               ROUND(
                       COUNT(CASE
                                 WHEN submission_count &gt; 0 AND (accepted_count * 100.0 / submission_count) &lt; 10
                                     THEN 1 END) * 100.0 /
                       COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END), 2
               )                                                                          as high_error_rate,
               -- 平台整体错误率
               ROUND(
                       (SUM(submission_count) - SUM(accepted_count)) * 100.0 / GREATEST(SUM(submission_count), 1), 2
               )                                                                          as platform_error_rate,
               -- 最近更新的问题题目
               COUNT(CASE
                         WHEN update_time &gt;= DATE_SUB(NOW(), INTERVAL #{timeWindow} MINUTE)
                             THEN 1 END)                                                  as recently_problematic
        FROM problem
        WHERE is_deleted = 0
    </select>

    <!-- 获取实时性能监控 -->
    <select id="getRealTimePerformanceMonitoring" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                     as total_problems,
               -- 性能分布
               COUNT(CASE WHEN time_limit &lt;= 1000 THEN 1 END)            as fast_problems,
               COUNT(CASE WHEN time_limit BETWEEN 1001 AND 3000 THEN 1 END) as medium_problems,
               COUNT(CASE WHEN time_limit &gt; 3000 THEN 1 END)             as slow_problems,
               -- 内存分布
               COUNT(CASE WHEN memory_limit &lt;= 128 THEN 1 END)           as low_memory_problems,
               COUNT(CASE WHEN memory_limit BETWEEN 129 AND 512 THEN 1 END) as medium_memory_problems,
               COUNT(CASE WHEN memory_limit &gt; 512 THEN 1 END)            as high_memory_problems,
               -- 平均性能指标
               ROUND(AVG(time_limit), 2)                                    as avg_time_limit,
               ROUND(AVG(memory_limit), 2)                                  as avg_memory_limit,
               -- 性能异常检测
               COUNT(CASE
                         WHEN time_limit &gt; (SELECT AVG(time_limit) * 3 FROM problem WHERE is_deleted = 0)
                             THEN 1 END)                                    as time_anomalies,
               COUNT(CASE
                         WHEN memory_limit &gt; (SELECT AVG(memory_limit) * 3 FROM problem WHERE is_deleted = 0)
                             THEN 1 END)                                    as memory_anomalies,
               -- 最近性能变更
               COUNT(CASE
                         WHEN update_time &gt;= DATE_SUB(NOW(), INTERVAL #{timeWindow} MINUTE)
                             THEN 1 END)                                    as recently_updated_performance
        FROM problem
        WHERE is_deleted = 0
    </select>


<!-- 获取题目提交量预测 -->
<select id="getProblemSubmissionPrediction" resultType="java.util.HashMap">
    SELECT p.id                           as problem_id,
           p.title,
           p.submission_count             as current_submissions,
           -- 移除 view_count 相关统计
           0                              as view_count,
           DATEDIFF(NOW(), p.created_at) as days_since_creation,
           -- 提交趋势预测
           ROUND(
                   p.submission_count *
                   (1 + (p.submission_count / GREATEST(DATEDIFF(NOW(), p.created_at), 1) * #{predictDays} / 100)),
                   0
           )                              as predicted_submissions,
           -- 预测增长率
           ROUND(
                   (p.submission_count / GREATEST(DATEDIFF(NOW(), p.created_at), 1) * #{predictDays}), 2
           )                              as predicted_growth,
           -- 预测置信度
           CASE
               WHEN DATEDIFF(NOW(), p.created_at) > 30 AND p.submission_count > 10 THEN 'HIGH'
               WHEN DATEDIFF(NOW(), p.created_at) > 7 AND p.submission_count > 1 THEN 'MEDIUM'
               ELSE 'LOW'
               END                        as prediction_confidence,
           -- 影响因素
           p.difficulty,
           p.problem_type,
           p.visibility
    FROM problem p
    WHERE p.is_deleted = 0
      AND p.id = #{problemId}
</select>
    <!-- 获取平台增长预测 -->
    <select id="getPlatformGrowthPrediction" resultType="java.util.HashMap">
        SELECT COUNT(*)                                                                       as current_total_problems,
               COUNT(CASE WHEN created_at &gt;= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) as recent_month_problems,
               COUNT(CASE WHEN created_at &gt;= DATE_SUB(NOW(), INTERVAL 90 DAY) THEN 1 END) as recent_quarter_problems,
               -- 增长率计算
               ROUND(
                       COUNT(CASE WHEN created_at &gt;= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) / 30.0 *
                       #{predictMonths} * 30, 0
               )                                                                              as predicted_new_problems,
               -- 预测总数
               COUNT(*) + ROUND(
                       COUNT(CASE WHEN created_at &gt;= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) / 30.0 *
                       #{predictMonths} * 30, 0
                          )                                                                   as predicted_total_problems,
               -- 增长趋势
               ROUND(
                       COUNT(CASE WHEN created_at &gt;= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) * 100.0 /
                       GREATEST(COUNT(CASE
                                          WHEN created_at BETWEEN DATE_SUB(NOW(), INTERVAL 60 DAY) AND DATE_SUB(NOW(), INTERVAL 30 DAY)
                                              THEN 1 END), 1), 2
               )                                                                              as monthly_growth_rate,
               -- 预测质量指标
               ROUND(AVG(
                             CASE
                                 WHEN submission_count &gt; 0
                                     THEN (accepted_count * 100.0 / submission_count)
                                 ELSE 0
                                 END
                     ),
                     2)                                                                       as predicted_acceptance_rate,
               -- 预测活跃度
               COUNT(DISTINCT creator_id)                                                     as current_creators,
               ROUND(COUNT(DISTINCT creator_id) * (1 + #{predictMonths} * 0.1), 0)            as predicted_creators
        FROM problem
        WHERE is_deleted = 0
    </select>


<!-- 获取题目流行度预测 -->
<select id="getProblemPopularityPrediction" resultType="java.util.HashMap">
    SELECT p.id    as problem_id,
           p.title,
           p.difficulty,
           p.submission_count,
           -- 移除 view_count 相关统计
           0       as view_count,
           -- 流行度评分（调整计算方式）
           ROUND(
                   (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                   GREATEST(DATEDIFF(NOW(), p.created_at), 1), 2
           )       as current_popularity_score,
           -- 流行度预测
           ROUND(
                   (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                   GREATEST(DATEDIFF(NOW(), p.created_at), 1) *
                   (1 + #{timeRange} * 0.01), 2
           )       as predicted_popularity_score,
           -- 预测排名变化
           CASE
               WHEN p.submission_count > (SELECT AVG(submission_count) FROM problem WHERE is_deleted = 0)
                   THEN 'RISING'
               WHEN p.submission_count &lt; (SELECT AVG(submission_count) FROM problem WHERE is_deleted = 0) * 0.5
                   THEN 'DECLINING'
               ELSE 'STABLE'
               END as popularity_trend,
           -- 推荐等级
           CASE
               WHEN (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                    GREATEST(DATEDIFF(NOW(), p.created_at), 1) > 100 THEN 'HOT'
               WHEN (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                    GREATEST(DATEDIFF(NOW(), p.created_at), 1) > 50 THEN 'TRENDING'
               WHEN (p.submission_count * 0.7 + p.accepted_count * 0.3) /
                    GREATEST(DATEDIFF(NOW(), p.created_at), 1) > 10 THEN 'POPULAR'
               ELSE 'NORMAL'
               END as recommendation_level
    FROM problem p
    WHERE p.is_deleted = 0
    ORDER BY predicted_popularity_score DESC
        LIMIT #{limit}
</select>


    <!-- 统一的统计信息接口（原始数据版本） -->
    <select id="getUnifiedStatisticsRaw" resultType="java.util.HashMap">
        <choose>
            <!-- 基础统计 -->
            <when test="request.scope.name() == 'BASIC'">
                SELECT
                problem_type,
                difficulty,
                COUNT(*) as total_count,
                SUM(CASE WHEN status = 1 THEN 1 ELSE 0 END) as active_count,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(AVG(CASE WHEN submission_count > 0 THEN accepted_count * 1.0 / submission_count ELSE 0 END), 4) as
                avg_acceptance_rate,
                MAX(submission_count) as max_submissions,
                MIN(CASE WHEN submission_count > 0 THEN submission_count ELSE NULL END) as min_submissions
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
                <if test="request.creatorIds != null and request.creatorIds.size() > 0">
                    AND creator_id IN
                    <foreach item="creatorId" collection="request.creatorIds" open="(" separator="," close=")">
                        #{creatorId}
                    </foreach>
                </if>
                GROUP BY problem_type, difficulty
                ORDER BY problem_type, difficulty
            </when>

            <!-- 详细统计 -->
            <when test="request.scope.name() == 'DETAILED'">
                SELECT
                COUNT(*) as total_problems,
                SUM(CASE WHEN difficulty = 'EASY' THEN 1 ELSE 0 END) as easy_count,
                SUM(CASE WHEN difficulty = 'MEDIUM' THEN 1 ELSE 0 END) as medium_count,
                SUM(CASE WHEN difficulty = 'HARD' THEN 1 ELSE 0 END) as hard_count,
                SUM(CASE WHEN problem_type = 'ALGORITHM' THEN 1 ELSE 0 END) as algorithm_count,
                SUM(CASE WHEN problem_type = 'PRACTICE' THEN 1 ELSE 0 END) as practice_count,
                SUM(CASE WHEN problem_type = 'DEBUG' THEN 1 ELSE 0 END) as debug_count,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(AVG(CASE WHEN submission_count > 0 THEN accepted_count / submission_count ELSE 0 END), 4) as
                avg_acceptance_rate,
                MAX(submission_count) as max_submissions,
                MIN(CASE WHEN submission_count > 0 THEN submission_count ELSE NULL END) as min_submissions
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
                AND status = 1
            </when>

            <!-- 总体统计 -->
            <when test="request.scope.name() == 'OVERALL'">
                SELECT
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                COUNT(CASE WHEN status = 0 THEN 1 END) as disabled_problems,
                COUNT(CASE WHEN status = 2 THEN 1 END) as draft_problems,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                ROUND(CASE WHEN SUM(submission_count) > 0 THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0 END, 2) as overall_acceptance_rate,
                COUNT(DISTINCT creator_id) as total_creators,
                AVG(time_limit) as avg_time_limit,
                AVG(memory_limit) as avg_memory_limit,
                COUNT(CASE WHEN submission_count = 0 THEN 1 END) as zero_submission_problems,
                COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) > 30 THEN 1 END) as stale_problems,
                ROUND(AVG(DATEDIFF(CURRENT_DATE, created_at)), 2) as avg_problem_age_days,
                COUNT(CASE WHEN visibility = 1 THEN 1 END) as public_problems,
                COUNT(CASE WHEN visibility = 0 THEN 1 END) as private_problems
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
            </when>

            <!-- 仪表盘统计 -->
            <when test="request.scope.name() == 'DASHBOARD'">
                SELECT
                COUNT(*) as total_problems,
                COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
                COUNT(DISTINCT creator_id) as total_creators,
                SUM(submission_count) as total_submissions,
                SUM(accepted_count) as total_accepted,
                COUNT(CASE WHEN DATE(created_at) = CURRENT_DATE THEN 1 END) as problems_created_today,
                COUNT(CASE WHEN DATE(updated_at) = CURRENT_DATE THEN 1 END) as problems_updated_today,
                COUNT(CASE WHEN created_at >= DATE_SUB(CURRENT_DATE, INTERVAL 7 DAY) THEN 1 END) as
                problems_created_this_week,
                COUNT(CASE WHEN created_at >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY) THEN 1 END) as
                problems_created_this_month,
                COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END) as easy_problems,
                COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
                COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END) as hard_problems,
                COUNT(CASE WHEN submission_count > 100 THEN 1 END) as hot_problems,
                COUNT(CASE WHEN submission_count = 0 THEN 1 END) as cold_problems,
                ROUND(CASE WHEN SUM(submission_count) > 0 THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                ELSE 0 END, 2) as overall_acceptance_rate
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
            </when>

            <!-- 添加新的聚合统计功能 -->
            <when test="request.scope.name() == 'AGGREGATED'">
                    SELECT
            COUNT(*) as total_problems,
            COUNT(DISTINCT problem_type) as problem_type_count,
            COUNT(DISTINCT difficulty) as difficulty_levels,
            COUNT(DISTINCT creator_id) as creator_count,
            SUM(submission_count) as total_submissions,
            SUM(accepted_count) as total_accepted,
            -- 移除 view_count 相关统计
            0 as total_views,
            ROUND(AVG(CASE WHEN submission_count > 0 THEN accepted_count * 1.0 / submission_count ELSE 0 END), 4) as
            avg_acceptance_rate,
            MAX(submission_count) as max_submissions,
            MIN(CASE WHEN submission_count > 0 THEN submission_count ELSE NULL END) as min_submissions,
            ROUND(AVG(time_limit), 2) as avg_time_limit,
            ROUND(AVG(memory_limit), 2) as avg_memory_limit,
            COUNT(CASE WHEN status = 1 THEN 1 END) as active_problems,
            COUNT(CASE WHEN status = 0 THEN 1 END) as inactive_problems,
            COUNT(CASE WHEN submission_count = 0 THEN 1 END) as zero_submission_problems,
            COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) as new_problems_last_30days
            FROM problem
            WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
                <if test="request.creatorIds != null and request.creatorIds.size() > 0">
                    AND creator_id IN
                    <foreach item="creatorId" collection="request.creatorIds" open="(" separator="," close=")">
                        #{creatorId}
                    </foreach>
                </if>
            </when>
        </choose>
    </select>

    <!-- 统一的统计信息接口 -->
    <select id="getUnifiedStatistics" resultType="fun.timu.oj.judge.model.VTO.UnifiedStatisticsVTO">
        <choose>
            <!-- 基础统计 -->
            <when test="request.scope.name() == 'BASIC'">
                SELECT
                #{request.scope} as scope,
                NOW() as timestamp,
                'v1.0' as dataVersion,
                JSON_OBJECT(
                'total_problems', COUNT(*),
                'problem_type', problem_type,
                'difficulty', difficulty,
                'total_count', COUNT(*),
                'active_count', SUM(CASE WHEN status = 1 THEN 1 ELSE 0 END),
                'total_submissions', SUM(submission_count),
                'total_accepted', SUM(accepted_count),
                'avg_acceptance_rate', ROUND(AVG(CASE WHEN submission_count > 0 THEN accepted_count / submission_count
                ELSE 0 END), 4)
                ) as data,
                JSON_OBJECT(
                'queryTime', NOW(),
                'resultCount', COUNT(*),
                'hasFilter',
                <if test="request.difficulties != null or request.problemTypes != null or request.statuses != null">
                    true
                </if>
                <if test="request.difficulties == null and request.problemTypes == null and request.statuses == null">
                    false
                </if>
                ) as metadata
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
                GROUP BY problem_type, difficulty
                ORDER BY problem_type, difficulty
            </when>

            <!-- 详细统计 -->
            <when test="request.scope.name() == 'DETAILED'">
                SELECT
                #{request.scope} as scope,
                NOW() as timestamp,
                'v1.0' as dataVersion,
                JSON_OBJECT(
                'total_problems', COUNT(*),
                'easy_count', SUM(CASE WHEN difficulty = 'EASY' THEN 1 ELSE 0 END),
                'medium_count', SUM(CASE WHEN difficulty = 'MEDIUM' THEN 1 ELSE 0 END),
                'hard_count', SUM(CASE WHEN difficulty = 'HARD' THEN 1 ELSE 0 END),
                'algorithm_count', SUM(CASE WHEN problem_type = 'ALGORITHM' THEN 1 ELSE 0 END),
                'practice_count', SUM(CASE WHEN problem_type = 'PRACTICE' THEN 1 ELSE 0 END),
                'debug_count', SUM(CASE WHEN problem_type = 'DEBUG' THEN 1 ELSE 0 END),
                'total_submissions', SUM(submission_count),
                'total_accepted', SUM(accepted_count),
                'avg_acceptance_rate', ROUND(AVG(CASE WHEN submission_count > 0 THEN accepted_count / submission_count
                ELSE 0 END), 4),
                'max_submissions', MAX(submission_count),
                'min_submissions', MIN(CASE WHEN submission_count > 0 THEN submission_count ELSE NULL END)
                ) as data,
                JSON_OBJECT(
                'queryTime', NOW(),
                'resultCount', COUNT(*),
                'hasFilter',
                <if test="request.difficulties != null or request.problemTypes != null or request.statuses != null">
                    true
                </if>
                <if test="request.difficulties == null and request.problemTypes == null and request.statuses == null">
                    false
                </if>,
                'includedMetrics', JSON_ARRAY('difficulty_distribution', 'type_distribution', 'submission_stats')
                ) as metadata
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
                AND status = 1
            </when>

            <!-- 总体统计 -->
            <when test="request.scope.name() == 'OVERALL'">
                SELECT
                #{request.scope} as scope,
                NOW() as timestamp,
                'v1.0' as dataVersion,
                JSON_OBJECT(
                'total_problems', COUNT(*),
                'active_problems', COUNT(CASE WHEN status = 1 THEN 1 END),
                'disabled_problems', COUNT(CASE WHEN status = 0 THEN 1 END),
                'draft_problems', COUNT(CASE WHEN status = 2 THEN 1 END),
                'total_submissions', SUM(submission_count),
                'total_accepted', SUM(accepted_count),
                'overall_acceptance_rate', ROUND(CASE WHEN SUM(submission_count) > 0 THEN (SUM(accepted_count) * 100.0 /
                SUM(submission_count)) ELSE 0 END, 2),
                'total_creators', COUNT(DISTINCT creator_id),
                'avg_time_limit', AVG(time_limit),
                'avg_memory_limit', AVG(memory_limit),
                'zero_submission_problems', COUNT(CASE WHEN submission_count = 0 THEN 1 END),
                'stale_problems', COUNT(CASE WHEN DATEDIFF(CURRENT_DATE, updated_at) > 30 THEN 1 END),
                'avg_problem_age_days', ROUND(AVG(DATEDIFF(CURRENT_DATE, created_at)), 2),
                'public_problems', COUNT(CASE WHEN visibility = 1 THEN 1 END),
                'private_problems', COUNT(CASE WHEN visibility = 0 THEN 1 END)
                ) as data,
                JSON_OBJECT(
                'queryTime', NOW(),
                'resultCount', COUNT(*),
                'hasFilter',
                <if test="request.difficulties != null or request.problemTypes != null or request.statuses != null">
                    true
                </if>
                <if test="request.difficulties == null and request.problemTypes == null and request.statuses == null">
                    false
                </if>,
                'includedMetrics', JSON_ARRAY('status_distribution', 'creator_stats', 'aging_analysis',
                'visibility_stats')
                ) as metadata
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
            </when>

            <!-- 仪表盘统计 -->
            <when test="request.scope.name() == 'DASHBOARD'">
                SELECT
                #{request.scope} as scope,
                NOW() as timestamp,
                'v1.0' as dataVersion,
                JSON_OBJECT(
                'total_problems', COUNT(*),
                'active_problems', COUNT(CASE WHEN status = 1 THEN 1 END),
                'total_creators', COUNT(DISTINCT creator_id),
                'total_submissions', SUM(submission_count),
                'total_accepted', SUM(accepted_count),
                'problems_created_today', COUNT(CASE WHEN DATE(created_at) = CURRENT_DATE THEN 1 END),
                'problems_updated_today', COUNT(CASE WHEN DATE(updated_at) = CURRENT_DATE THEN 1 END),
                'problems_created_this_week', COUNT(CASE WHEN created_at >= DATE_SUB(CURRENT_DATE, INTERVAL 7 DAY) THEN
                1 END),
                'problems_created_this_month', COUNT(CASE WHEN created_at >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)
                THEN 1 END),
                'easy_problems', COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END),
                'medium_problems', COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END),
                'hard_problems', COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END),
                'hot_problems', COUNT(CASE WHEN submission_count > 100 THEN 1 END),
                'cold_problems', COUNT(CASE WHEN submission_count = 0 THEN 1 END),
                'overall_acceptance_rate', ROUND(CASE WHEN SUM(submission_count) > 0 THEN (SUM(accepted_count) * 100.0 /
                SUM(submission_count)) ELSE 0 END, 2) as overall_acceptance_rate
                ) as data,
                JSON_OBJECT(
                'queryTime', NOW(),
                'resultCount', COUNT(*),
                'hasFilter',
                <if test="request.difficulties != null or request.problemTypes != null or request.statuses != null">
                    true
                </if>
                <if test="request.difficulties == null and request.problemTypes == null and request.statuses == null">
                    false
                </if>,
                'includedMetrics', JSON_ARRAY('daily_stats', 'weekly_stats', 'monthly_stats', 'difficulty_distribution',
                'activity_levels'),
                'refreshInterval', 300
                ) as metadata
                FROM problem
                WHERE is_deleted = 0
                <if test="request.startDate != null">
                    AND created_at >= #{request.startDate}
                </if>
                <if test="request.endDate != null">
                    AND created_at &lt;= #{request.endDate}
                </if>
                <if test="request.difficulties != null and request.difficulties.size() > 0">
                    AND difficulty IN
                    <foreach item="difficulty" collection="request.difficulties" open="(" separator="," close=")">
                        #{difficulty}
                    </foreach>
                </if>
                <if test="request.problemTypes != null and request.problemTypes.size() > 0">
                    AND problem_type IN
                    <foreach item="type" collection="request.problemTypes" open="(" separator="," close=")">
                        #{type}
                    </foreach>
                </if>
                <if test="request.statuses != null and request.statuses.size() > 0">
                    AND status IN
                    <foreach item="status" collection="request.statuses" open="(" separator="," close=")">
                        #{status}
                    </foreach>
                </if>
            </when>
        </choose>
    </select>
    <!-- 统一的排行榜查询接口 -->
    <select id="getProblemRanking" resultType="java.util.HashMap">
        SELECT
        p.id,
        p.title,
        p.title_en,
        p.difficulty,
        CASE
        WHEN p.difficulty = 0 THEN '简单'
        WHEN p.difficulty = 1 THEN '中等'
        WHEN p.difficulty = 2 THEN '困难'
        ELSE '未知'
        END as difficulty_name,
        p.problem_type,
        p.submission_count,
        p.accepted_count,
        ROUND(
        CASE
        WHEN p.submission_count > 0
        THEN (p.accepted_count * 100.0 / p.submission_count)
        ELSE 0
        END, 2
        ) as acceptance_rate,
        p.creator_id,
        p.created_at,
        p.updated_at,
        p.status,
        p.time_limit,
        p.memory_limit,
        <if test="criteria.includeCreatorInfo != null and criteria.includeCreatorInfo">
            p.creator_id as creator_info,
        </if>
        <choose>
            <!-- 热门题目排行 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                ROUND(
                p.submission_count * 0.7 +
                p.accepted_count * 0.3 +
                (CASE WHEN DATEDIFF(CURRENT_DATE, p.created_at) &lt; 30 THEN 10 ELSE 0 END)
                , 2) as ranking_score
            </when>
            <!-- 最难题目排行 -->
            <when test="criteria.type.name() == 'HARDEST'">
                ROUND(
                (100.0 - CASE
                WHEN p.submission_count > 0
                THEN (p.accepted_count * 100.0 / p.submission_count)
                ELSE 100
                END) +
                (p.time_limit / 1000.0 * 0.1) +
                (p.memory_limit / 256.0 * 0.1)
                , 2) as difficulty_score
            </when>
            <!-- 最简单题目排行 -->
            <when test="criteria.type.name() == 'EASIEST'">
                ROUND(
                (CASE WHEN p.submission_count > 0 THEN (p.accepted_count * 100.0 / p.submission_count) ELSE 0 END) -
                (p.time_limit / 1000.0 * 0.1) -
                (p.memory_limit / (1024.0 * 1024.0) / 256.0 * 0.1)
                , 2) as easiness_score
            </when>
            <!-- 高质量题目排行 -->
            <when test="criteria.type.name() == 'QUALITY'">
                ROUND(
                (CASE
                WHEN p.submission_count > 0
                THEN (p.accepted_count * 100.0 / p.submission_count)
                ELSE 0
                END) * 0.3 +
                (CASE WHEN p.submission_count BETWEEN 10 AND 1000 THEN 50 ELSE 0 END) +
                (CASE WHEN p.submission_count > 0 THEN 20 ELSE 0 END) +
                (CASE WHEN p.status = 1 THEN 10 ELSE 0 END) * 1
                , 2) as quality_score
            </when>
            <!-- 最新题目排行 -->
            <when test="criteria.type.name() == 'NEWEST'">
                UNIX_TIMESTAMP(p.created_at) as creation_timestamp,
                CASE
                WHEN DATEDIFF(CURRENT_DATE, p.created_at) = 0 THEN 100
                ELSE ROUND(p.submission_count / DATEDIFF(CURRENT_DATE, p.created_at), 2)
                END as daily_submission_rate
            </when>
            <!-- 零提交题目排行 -->
            <when test="criteria.type.name() == 'ZERO_SUBMISSION'">
                DATEDIFF(CURRENT_DATE, p.created_at) as days_since_creation,
                CASE
                WHEN p.status = 0 THEN 'DISABLED'
                WHEN p.status = 1 THEN 'ACTIVE'
                ELSE 'UNKNOWN'
                END as status_name
            </when>
            <!-- 最多提交题目排行 -->
            <when test="criteria.type.name() == 'MAX_SUBMISSION'">
                DATEDIFF(CURRENT_DATE, p.created_at) as days_since_creation,
                ROUND(p.submission_count / GREATEST(DATEDIFF(CURRENT_DATE, p.created_at), 1), 2) as
                daily_submission_rate,
                CASE
                WHEN p.status = 0 THEN 'DISABLED'
                WHEN p.status = 1 THEN 'ACTIVE'
                ELSE 'UNKNOWN'
                END as status_name,
                CASE
                WHEN p.submission_count > 1000 THEN 'EXTREMELY_POPULAR'
                WHEN p.submission_count > 500 THEN 'VERY_POPULAR'
                WHEN p.submission_count > 100 THEN 'POPULAR'
                WHEN p.submission_count > 50 THEN 'MODERATE'
                ELSE 'LOW'
                END as popularity_level
            </when>
            <!-- 创建者贡献排行 -->
            <when test="criteria.type.name() == 'CREATOR_CONTRIBUTION'">
                COUNT(*) as problems_created,
                COUNT(CASE WHEN p.status = 1 THEN 1 END) as active_problems,
                SUM(p.submission_count) as total_submissions_received,
                SUM(p.accepted_count) as total_accepted_received,
                ROUND(AVG(
                CASE
                WHEN p.submission_count > 0
                THEN (p.accepted_count * 100.0 / p.submission_count)
                ELSE 0
                END
                ), 2) as avg_acceptance_rate,
                ROUND(
                COUNT(*) * 10 +
                SUM(p.submission_count) * 0.1 +
                SUM(p.accepted_count) * 0.2 +
                COUNT(CASE WHEN p.difficulty = 'EASY' THEN 1 END) * 5 +
                COUNT(CASE WHEN p.difficulty = 'MEDIUM' THEN 1 END) * 10 +
                COUNT(CASE WHEN p.difficulty = 'HARD' THEN 1 END) * 15
                , 2) as contribution_score
            </when>
        </choose>
        FROM problem p
        WHERE p.is_deleted = 0
        <choose>
            <!-- 热门题目排行条件 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                AND p.status = 1
                <if test="criteria.timeRange != null">
                    AND p.created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
            </when>
            <!-- 最难题目排行条件 -->
            <when test="criteria.type.name() == 'HARDEST'">
                AND p.status = 1
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
            </when>
            <!-- 最简单题目排行条件 -->
            <when test="criteria.type.name() == 'EASIEST'">
                AND p.status = 1
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
            </when>
            <!-- 高质量题目排行条件 -->
            <when test="criteria.type.name() == 'QUALITY'">
                <!-- 质量排行无特殊条件 -->
            </when>
            <!-- 最新题目排行条件 -->
            <when test="criteria.type.name() == 'NEWEST'">
                AND p.status = 1
                <if test="criteria.dayRange != null">
                    AND p.created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.dayRange} DAY)
                </if>
            </when>
            <!-- 零提交题目排行条件 -->
            <when test="criteria.type.name() == 'ZERO_SUBMISSION'">
                AND p.submission_count = 0
            </when>
            <!-- 最多提交题目排行条件 -->
            <when test="criteria.type.name() == 'MAX_SUBMISSION'">
                AND p.submission_count > 0
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
            </when>
            <!-- 创建者贡献排行条件 -->
            <when test="criteria.type.name() == 'CREATOR_CONTRIBUTION'">
                AND p.creator_id IS NOT NULL
                <if test="criteria.timeRange != null">
                    AND p.created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
            </when>
        </choose>
        <choose>
            <!-- 创建者贡献排行需要分组 -->
            <when test="criteria.type.name() == 'CREATOR_CONTRIBUTION'">
                GROUP BY p.creator_id
            </when>
        </choose>
        <choose>
            <!-- 不同排行榜的排序规则 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                ORDER BY ranking_score DESC, p.submission_count DESC, p.accepted_count DESC
            </when>
            <when test="criteria.type.name() == 'HARDEST'">
                ORDER BY acceptance_rate ASC, difficulty_score DESC, p.submission_count DESC
            </when>
            <when test="criteria.type.name() == 'EASIEST'">
                ORDER BY acceptance_rate DESC, easiness_score DESC, p.submission_count DESC
            </when>
            <when test="criteria.type.name() == 'QUALITY'">
                ORDER BY quality_score DESC, p.submission_count DESC
            </when>
            <when test="criteria.type.name() == 'NEWEST'">
                ORDER BY p.created_at DESC, daily_submission_rate DESC
            </when>
            <when test="criteria.type.name() == 'ZERO_SUBMISSION'">
                ORDER BY days_since_creation DESC, p.created_at DESC
            </when>
            <when test="criteria.type.name() == 'MAX_SUBMISSION'">
                ORDER BY p.submission_count DESC, daily_submission_rate DESC, p.accepted_count DESC
            </when>
            <when test="criteria.type.name() == 'CREATOR_CONTRIBUTION'">
                ORDER BY contribution_score DESC, problems_created DESC
            </when>
        </choose>
        <if test="criteria.limit != null and criteria.limit > 0">
            LIMIT #{criteria.limit}
        </if>
    </select>

    <!-- 统一的排行榜查询接口（实体版本） -->
    <select id="getProblemRankingEntities" resultMap="BaseResultMap">
        SELECT
        <include refid="Base_Column_List"/>
        FROM problem p
        WHERE p.is_deleted = 0
        <choose>
            <!-- 热门题目排行条件 -->
            <when test="criteria.type.name() == 'POPULARITY'">
                AND p.status = 1
                <if test="criteria.timeRange != null">
                    AND p.created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.timeRange} DAY)
                </if>
                ORDER BY p.submission_count DESC, p.accepted_count DESC
            </when>
            <!-- 最难题目排行条件 -->
            <when test="criteria.type.name() == 'HARDEST'">
                AND p.status = 1
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
                ORDER BY (CASE WHEN p.submission_count > 0 THEN (p.accepted_count * 100.0 / p.submission_count) ELSE 100
                END) ASC, p.submission_count DESC
            </when>
            <!-- 最简单题目排行条件 -->
            <when test="criteria.type.name() == 'EASIEST'">
                AND p.status = 1
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
                ORDER BY (CASE WHEN p.submission_count > 0 THEN (p.accepted_count * 100.0 / p.submission_count) ELSE 0
                END) DESC, p.submission_count DESC
            </when>
            <!-- 高质量题目排行条件 -->
            <when test="criteria.type.name() == 'QUALITY'">
                ORDER BY (
                (CASE WHEN p.submission_count > 0 THEN (p.accepted_count * 100.0 / p.submission_count) ELSE 0 END) * 0.3
                +
                (CASE WHEN p.submission_count BETWEEN 10 AND 1000 THEN 50 ELSE 0 END) +
                (CASE WHEN p.submission_count > 0 THEN 20 ELSE 0 END) +
                (CASE WHEN p.status = 1 THEN 10 ELSE 0 END)
                ) DESC, p.submission_count DESC
            </when>
            <!-- 最新题目排行条件 -->
            <when test="criteria.type.name() == 'NEWEST'">
                AND p.status = 1
                <if test="criteria.dayRange != null">
                    AND p.created_at >= DATE_SUB(CURRENT_DATE, INTERVAL #{criteria.dayRange} DAY)
                </if>
                ORDER BY p.created_at DESC, p.submission_count DESC
            </when>
            <!-- 零提交题目排行条件 -->
            <when test="criteria.type.name() == 'ZERO_SUBMISSION'">
                AND p.submission_count = 0
                ORDER BY p.created_at DESC
            </when>
            <!-- 最多提交题目排行条件 -->
            <when test="criteria.type.name() == 'MAX_SUBMISSION'">
                AND p.submission_count > 0
                <if test="criteria.minSubmissions != null">
                    AND p.submission_count >= #{criteria.minSubmissions}
                </if>
                ORDER BY p.submission_count DESC, p.accepted_count DESC
            </when>
        </choose>
        <if test="criteria.limit != null and criteria.limit > 0">
            LIMIT #{criteria.limit}
        </if>
    </select>


        <!-- 统一的趋势分析接口（替代原有的4个冗余接口） -->
        <select id="getTrendAnalysis" resultType="java.util.HashMap">
            <choose>
                <!-- 题目创建趋势分析 -->
                <when test="criteria.type.name() == 'PROBLEM_CREATION'">
                    SELECT
                    <choose>
                        <when test="criteria.timeGranularity == 'DAY'">
                            DATE(created_at) as time_period,
                            DATE_FORMAT(created_at, '%Y-%m-%d') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'WEEK'">
                            DATE(DATE_SUB(created_at, INTERVAL WEEKDAY(created_at) DAY)) as time_period,
                            CONCAT(YEAR(created_at), '-W', LPAD(WEEK(created_at), 2, '0')) as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'MONTH'">
                            DATE_FORMAT(created_at, '%Y-%m-01') as time_period,
                            DATE_FORMAT(created_at, '%Y-%m') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'YEAR'">
                            DATE_FORMAT(created_at, '%Y-01-01') as time_period,
                            YEAR(created_at) as time_label
                        </when>
                        <otherwise>
                            DATE(created_at) as time_period,
                            DATE_FORMAT(created_at, '%Y-%m-%d') as time_label
                        </otherwise>
                    </choose>,
                    COUNT(*) as problems_created,
                    COUNT(CASE WHEN difficulty = 'EASY' THEN 1 END) as easy_problems,
                    COUNT(CASE WHEN difficulty = 'MEDIUM' THEN 1 END) as medium_problems,
                    COUNT(CASE WHEN difficulty = 'HARD' THEN 1 END) as hard_problems,
                    COUNT(DISTINCT problem_type) as unique_types,
                    ROUND(AVG(time_limit), 2) as avg_time_limit,
                    ROUND(AVG(memory_limit), 2) as avg_memory_limit
                    FROM problem
                    WHERE is_deleted = 0
                    <if test="criteria.startTime != null">
                        AND created_at &gt;= #{criteria.startTime}
                    </if>
                    <if test="criteria.endTime != null">
                        AND created_at &lt;= #{criteria.endTime}
                    </if>
                    <if test="criteria.problemId != null">
                        AND id = #{criteria.problemId}
                    </if>
                    <if test="criteria.userId != null">
                        AND creator_id = #{criteria.userId}
                    </if>
                    GROUP BY time_period, time_label
                    ORDER BY time_period
                    <if test="criteria.limit != null">
                        LIMIT #{criteria.limit}
                    </if>
                </when>
    
                <!-- 提交趋势分析 -->
                <when test="criteria.type.name() == 'SUBMISSION_TREND'">
                    SELECT
                    <choose>
                        <when test="criteria.timeGranularity == 'DAY'">
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'WEEK'">
                            DATE(DATE_SUB(updated_at, INTERVAL WEEKDAY(updated_at) DAY)) as time_period,
                            CONCAT(YEAR(updated_at), '-W', LPAD(WEEK(updated_at), 2, '0')) as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'MONTH'">
                            DATE_FORMAT(updated_at, '%Y-%m-01') as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'YEAR'">
                            DATE_FORMAT(updated_at, '%Y-01-01') as time_period,
                            YEAR(updated_at) as time_label
                        </when>
                        <otherwise>
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </otherwise>
                    </choose>,
                    SUM(submission_count) as total_submissions,
                    COUNT(*) as active_problems,
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    MAX(submission_count) as max_submissions,
                    MIN(submission_count) as min_submissions,
                    COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) as problems_with_submissions
                    FROM problem
                    WHERE is_deleted = 0 AND status = 1
                    <if test="criteria.startTime != null">
                        AND updated_at &gt;= #{criteria.startTime}
                    </if>
                    <if test="criteria.endTime != null">
                        AND updated_at &lt;= #{criteria.endTime}
                    </if>
                    <if test="criteria.problemId != null">
                        AND id = #{criteria.problemId}
                    </if>
                    <if test="criteria.userId != null">
                        AND creator_id = #{criteria.userId}
                    </if>
                    GROUP BY time_period, time_label
                    ORDER BY time_period
                    <if test="criteria.limit != null">
                        LIMIT #{criteria.limit}
                    </if>
                </when>
    
                <!-- 通过率趋势分析 -->
                <when test="criteria.type.name() == 'ACCEPTANCE_RATE_TREND'">
                    SELECT
                    <choose>
                        <when test="criteria.timeGranularity == 'DAY'">
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'WEEK'">
                            DATE(DATE_SUB(updated_at, INTERVAL WEEKDAY(updated_at) DAY)) as time_period,
                            CONCAT(YEAR(updated_at), '-W', LPAD(WEEK(updated_at), 2, '0')) as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'MONTH'">
                            DATE_FORMAT(updated_at, '%Y-%m-01') as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'YEAR'">
                            DATE_FORMAT(updated_at, '%Y-01-01') as time_period,
                            YEAR(updated_at) as time_label
                        </when>
                        <otherwise>
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </otherwise>
                    </choose>,
                    ROUND(
                    CASE
                    WHEN SUM(submission_count) &gt; 0
                    THEN (SUM(accepted_count) * 100.0 / SUM(submission_count))
                    ELSE 0
                    END, 2
                    ) as acceptance_rate,
                    SUM(submission_count) as total_submissions,
                    SUM(accepted_count) as total_accepted,
                    COUNT(*) as total_problems,
                    COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) as problems_with_submissions,
                    ROUND(AVG(
                    CASE
                    WHEN submission_count &gt; 0
                    THEN (accepted_count * 100.0 / submission_count)
                    ELSE 0
                    END), 2
                    ) as avg_acceptance_rate_per_problem
                    FROM problem
                    WHERE is_deleted = 0 AND status = 1
                    <if test="criteria.startTime != null">
                        AND updated_at &gt;= #{criteria.startTime}
                    </if>
                    <if test="criteria.endTime != null">
                        AND updated_at &lt;= #{criteria.endTime}
                    </if>
                    <if test="criteria.problemId != null">
                        AND id = #{criteria.problemId}
                    </if>
                    <if test="criteria.userId != null">
                        AND creator_id = #{criteria.userId}
                    </if>
                    GROUP BY time_period, time_label
                    ORDER BY time_period
                    <if test="criteria.limit != null">
                        LIMIT #{criteria.limit}
                    </if>
                </when>
    
                <!-- 题目活跃度时间趋势 -->
                <when test="criteria.type.name() == 'PROBLEM_ACTIVITY_TREND'">
                    SELECT
                    <choose>
                        <when test="criteria.timeGranularity == 'DAY'">
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'WEEK'">
                            DATE(DATE_SUB(updated_at, INTERVAL WEEKDAY(updated_at) DAY)) as time_period,
                            CONCAT(YEAR(updated_at), '-W', LPAD(WEEK(updated_at), 2, '0')) as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'MONTH'">
                            DATE_FORMAT(updated_at, '%Y-%m-01') as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m') as time_label
                        </when>
                        <when test="criteria.timeGranularity == 'YEAR'">
                            DATE_FORMAT(updated_at, '%Y-01-01') as time_period,
                            YEAR(updated_at) as time_label
                        </when>
                        <otherwise>
                            DATE(updated_at) as time_period,
                            DATE_FORMAT(updated_at, '%Y-%m-%d') as time_label
                        </otherwise>
                    </choose>,
                    COUNT(*) as total_problems,
                    SUM(submission_count) as total_submissions,
                    SUM(accepted_count) as total_accepted,
                    SUM(view_count) as total_views,
                    ROUND(AVG(submission_count), 2) as avg_submissions_per_problem,
                    ROUND(AVG(view_count), 2) as avg_views_per_problem,
                    COUNT(CASE WHEN submission_count &gt; 0 THEN 1 END) as active_problems,
                    MAX(submission_count) as max_submissions_single_problem,
                    COUNT(CASE WHEN submission_count > (SELECT AVG(submission_count) FROM problem WHERE is_deleted = 0) THEN
                    1 END)
                    as above_avg_activity_problems
                    FROM problem
                    WHERE is_deleted = 0 AND status = 1
                    <if test="criteria.startTime != null">
                        AND updated_at &gt;= #{criteria.startTime}
                    </if>
                    <if test="criteria.endTime != null">
                        AND updated_at &lt;= #{criteria.endTime}
                    </if>
                    <if test="criteria.problemId != null">
                        AND id = #{criteria.problemId}
                    </if>
                    <if test="criteria.userId != null">
                        AND creator_id = #{criteria.userId}
                    </if>
                    GROUP BY time_period, time_label
                    ORDER BY time_period
                    <if test="criteria.limit != null">
                        LIMIT #{criteria.limit}
                    </if>
                </when>
            </choose>
        </select>

</mapper>
